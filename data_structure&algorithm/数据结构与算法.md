



在线脑图：https://www.processon.com/view/link/617aa00f07912943dd03d4f4



# 开发环境

Mac C语言环境配置

软件：Visual Studio Code

>  Coder Runner 插件 :目的是为了实现在Visual Studio Code中 运行C语言代码

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gusnuqw23tj60vy0te76z02.jpg" alt="image-20210925102319407" style="zoom:33%;" />  



# 一、数据结构的概述



![image-20211111194055284](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211113184245.jpg)

## 1、定义

> 我们如何把现实中大量而复杂的问题以`特定的数据类型`和`特定的存储结构`保存到主存储器（内存）当中，以及在此基础上为实现某个功能（比如查找某个元素，删除某个元素，对所有元素进行排序）而执行的相应操作，这个相应的操作也叫算法



> 狭义：
>
> ​		数据结构是专门研究数据存储问题
>
> ​		数据的存储包含两方面：个体的存储+个体关系的存储
>
> 广义：
>
> ​		数据结构既包含数据的存储也包含数据的操作
>
> ​		对存储数据的操作就是算法
>
> 数据结构  = 个体 + 个体的关系
>
> 算法 = 对存储数据的操作



## 2、算法

> **什么是算法？**

广义：算法是对存储对象的操作

狭义：指的是解决问题的方法和步骤





> 解题的方法和步骤

**如何衡量算法的标准？**

1、时间复杂度：程序大概要执行的次数，而非执行的时间

2、空间复杂度：算法执行过程中大概所占用的最大内存

3、难易程度

4、健壮性

## 3、数据结构的地位？

> 数据结构是软件中最核心的课程

程序	=	数据的存储 + 数据的操作 + 可以被计算机执行的语言





## 4、数据存储有几种结构？

1、线性结构

- 连续存储【数组】

  - 优点：存储速度快

  - 缺点：插入删除元素时很慢

    ​				空间有限制

    ​				事先必须知道数组的长度

    ​				需要大块连续存储块

- 离散存储【链表】

  - 优点：空间无限制
  - 缺点：存储速度慢

- 线性结构的应用----【栈】

- 线性结构的应用----【队列】

2、非线性结构

- 树
- 图



# 

# 二、预备知识

## 1、指针

（1）、指针的重要性：C语言的灵魂

（2）、定义：

- 地址：
  - 内存的存储编号（门牌号）
  - 从0开始的非负整数
  - 范围：0  --> FFFFFFFFF【0-4G-1】
- 指针：
  - 指针就是地址，地址就是指针
  - **指针变量**是存放内存单元的地址的变量
  - 指针的本质是一个操作受限的非负整数



## 2、结构体

> （1）为什么会出现结构体？

为了表达一些复杂的数据，普通的基本类型变量无法满足要求，结构体由此诞生！



> （2）什么叫结构体

结构体是用户根据我们实际需要可自己定义的复合数据类型



> （3）注意事项：



## 3、动态内存的分配和释放







## 4、递归



### 一、递归原理分析

#### （1）递归的定义



![image-20211031191124500](https://tva1.sinaimg.cn/large/008i3skNgy1gvypev6j1vj31l00u0gra.jpg)

#### （2）分治法

![image-20211031191109911](https://tva1.sinaimg.cn/large/008i3skNgy1gvypelzmwlj31r60tiqat.jpg)

![image-20211031191226124](https://tva1.sinaimg.cn/large/008i3skNgy1gvypfxn49uj31eo0siaf8.jpg)

#### （3）函数调用过程





![image-20211031191543567](https://tva1.sinaimg.cn/large/008i3skNgy1gvypjd9q9tj31e60u044a.jpg)



#### （4）递归与栈

![image-20211031191846908](https://tva1.sinaimg.cn/large/008i3skNgy1gvypmj10epj31e60u042o.jpg)



**用阶层问题分析递归与栈**

![image-20211031192245305](https://tva1.sinaimg.cn/large/008i3skNgy1gvypqofp7kj31600u0gry.jpg)



![image-20211031192450396](https://tva1.sinaimg.cn/large/008i3skNgy1gvypsu5vd3j31cj0u0q7o.jpg)



![image-20211031192547962](https://tva1.sinaimg.cn/large/008i3skNgy1gvyptu8i2qj31l60r6n13.jpg)



![image-20211031192714520](https://tva1.sinaimg.cn/large/008i3skNgy1gvypvc0qdhj31pk0tedkq.jpg)









### 二、相关应用



#### **（1）求阶层**

```c
#include<stdio.h>
// 求n的阶层
long getJC(long n){
    if(n==1){
        return 1;
    }else
    {
       return getJC(n-1) * n;
    }
    
    
}
int main(){
    printf("result=%ld",getJC(20));
    return 0;
}
```



#### **（2）1+2+3+...+100的和**

```c
#include<stdio.h>
// 求1到100的和
long getSum(long n){
    if(n==1){
        return 1;
    }else
    {
       return getSum(n-1) + n;
    }
    
    
}
int main(){
    printf("sum=%ld",getSum(100));
    return 0;
}
```



#### **（3）走迷宫**



#### **（4）汉诺塔**





>  函数的调用

**==当一个函数的运行期间调用另一个函数，在运行背调函数之前，系统需要完成三件事：==**

1）、将所有的`实际参数`，`返回地址`等信息发送给被调函数 

2）、 为被调函数的局部变量（也包括形参）分配内存空间

3）、将控制转移动到被调函数的入口，分配空间



**==从被调函数返回主调函数，系统也要完成三件事：==**

1）、保存被调函数的返回结果

2）、释放被调函数所占的存储空间

3）、依照被调函数保存的`返回地址`将控制转移到主调函数的地方

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv86peasnoj60ls0nu0ty02.jpg" alt="image-20211008203925747" style="zoom:33%;" /> 

 

>  递归的应用

数和森林就是以递归的方式定义的

数和图的很多算法都是以递归来实现的

很多数学公式都是以递归的方式来定义的









# 三、线性结构

> 什么是线性结构？
>
> 可以用一根线把所有节点串起来，否则为非线性结构（树、图）



## 1、顺序表

> （1）什么叫数组？
>
> ​	元素类型相同，大小相等
>
> （2）数组的优缺点？



**自创数组**

```c
#include<stdio.h>
#include<mm_malloc.h>
#include<stdlib.h> // 包含了exit();
/*
    模拟数组
*/

// 定义了一个数据类型，该数据类型的名字叫struct Arr,含有三个成员，分别是pBase，len，cnt
struct Arr{
    int *pBase; // 存储的是数组第一个元素的地址
    int len; // 数组所能容纳的最大元素个数
    int cnt; // 当前数组有效元素的个数
};

/*
所有声明
*/
void initArr(struct Arr *pArr, int length);
bool isEmpty(struct Arr *pArr); 
void showArr(struct Arr *pArr);
bool appendArr(struct Arr *pArr ,int val);
bool insertArr(struct Arr *pArr ,int pos,int val); 
bool isFull(struct Arr *pArr);
bool deleteArr(struct Arr *pArr ,int pos,int *pVal);
void inversionArr(struct Arr *pArr);
void softArr(struct Arr *pArr);

/*
主函数
*/
int main(){
    // int val;// 用于接收删除元素的值
    struct Arr arr;  // 定义一个变量arr，目前没有内容
    initArr(&arr,6);
    // printf("%d\n",arr.len);
    // showArr(&arr);
    // printf("\n---------------------\n");

    // appendArr(&arr,1);
    // appendArr(&arr,2);
    // appendArr(&arr,3);
    // appendArr(&arr,4);
    // appendArr(&arr,5);
    // appendArr(&arr,6);
    // appendArr(&arr,7);
    // showArr(&arr);
    // printf("\n---------------------\n");
    // insertArr(&arr,6,99);
    // showArr(&arr);


    // 测试deleteArr()
    // appendArr(&arr,1);
    // appendArr(&arr,2);
    // appendArr(&arr,3);
    // appendArr(&arr,4444);
    // appendArr(&arr,5);
    // appendArr(&arr,6);
    // showArr(&arr);
    // printf("\n---------------------\n");
    // deleteArr(&arr,4,&val); // val为用于接受所删除数据的值
    // printf("被删的元素值为：%d\n",val);
    // showArr(&arr);


    // 实现倒置
    // appendArr(&arr,1);
    // appendArr(&arr,2);
    // appendArr(&arr,3);
    // appendArr(&arr,4);
    // appendArr(&arr,5);
    // appendArr(&arr,6);
    // inversionArr(&arr);
    // showArr(&arr);
    // printf("\n---------------------\n");

    
    // 实现升序排序
    printf("\n---------------------\n");
    appendArr(&arr,2);
    appendArr(&arr,7);
    appendArr(&arr,5);
    appendArr(&arr,4);
    appendArr(&arr,8);
    appendArr(&arr,3);
    softArr(&arr);
    showArr(&arr);
    return 0;


}



/*
    初始化
*/
void initArr(struct Arr *pArr, int length){
    pArr->pBase = (int *)malloc(sizeof(int) * length); //pArr 这个指针变量所指向的那个结构体变量中的pBase
    if(NULL == pArr->pBase){
        printf("动态内存分配失败！\n");
        exit(-1); // 终止挣个程序
    }else{
        pArr->len = length; // 数组所能容纳的最大元素个数
        pArr->cnt = 0;
    }
    return;
}


/*
    显示输出
*/

void showArr(struct Arr *pArr){
    if(isEmpty(pArr)){
        printf("数组为空\n");
    }else{
       for (int i = 0; i < pArr->cnt; i++)
       {
           printf("%d  ",pArr->pBase[i]); 
           printf("\n");
       }
    }
}


/*
    判断数组是否为空
*/
bool isEmpty(struct Arr *pArr){
    if (0 == pArr->cnt){
        return true;
    }else{
        return false;
    }
}



/*
    追加
*/
bool appendArr(struct Arr *pArr ,int val){
    // 满了 不能追加
    if(isFull(pArr)){
        return false;
    }
    // 不满的时候可以追加   ： 1、 流程 2、功能 3、试错
    pArr->pBase[pArr->cnt] = val;
    pArr->cnt++;
    return true;
}
/*
    判断是否已满
*/
bool isFull(struct Arr *pArr){
    if(pArr->len  == pArr->cnt){
        printf("已满\n");
        return true;
    }else{
        return false;
    }
}

bool insertArr(struct Arr *pArr ,int pos,int val){
    // 1、判断是否已满，如果已满则不能插入
    if(isFull(pArr)){
        return false;
        
    }
    // 2、再判断是否越界
    if(pos <1 || pos>pArr->cnt+1){

        return false;
    }

    for(int i = pArr->cnt-1; i>=pos-1; i--){
        pArr->pBase[i+1] = pArr->pBase[i]; // 把最后一个 给 最后一个的下一个
    }
    pArr->pBase[pos-1] = val; // 插入
    pArr->cnt++; // 有效个数加1
    return true;
}

bool deleteArr(struct Arr *pArr ,int pos,int *pVal){
    if(isEmpty(pArr)){
        printf("数组为空\n");
        return false;
    }
    if(pos<1 && pos>pArr->cnt){
        printf("范围异常");
        return false;
    }

    // 先找到这个值
    *pVal = pArr->pBase[pos-1];
    // 开始删除
    for(int i = pos; i<pArr->cnt; i++){
        pArr->pBase[i-1] = pArr->pBase[i];
    }
    pArr->cnt--;// 有效个数减1
    return true;
}

void inversionArr(struct Arr *pArr){
    int i=0; //第一个
    int j=pArr->cnt-1; // 最后一个
    int temp;
    while (i<j) // 值互换
    {   
        temp = pArr->pBase[i];
        pArr->pBase[i] = pArr->pBase[j];
        pArr->pBase[j] = temp;
        i++;
        j--;
    }
    return;
 
}

void softArr(struct Arr *pArr){
    // 选择排序
    int temp;
    for(int i =0; i<pArr->cnt; i++){
        for(int j=i+1; j<pArr->cnt;j++){
            if(pArr->pBase[i]>pArr->pBase[j]){
                temp = pArr->pBase[i];
                pArr->pBase[i] = pArr->pBase[j];
                pArr->pBase[j] = temp;
            }
        }
    }



}
```

## 2、链表

> 预备知识-typedef关键词
>
> 目标：手敲链表



1、

```c
#include<stdio.h>
typedef int QQ;  //为int 从新多去一个名字 int = QQ
typedef struct Student{
    int sid;
    char name[100];
    char sex;
}St; // St  等同于struct Student

int main(){
    int i = 10;
    QQ j = 10; // QQ等同于int
    printf("%d %d",i,j);
    struct Student st;
    struct Student *ss;

    St st; // St st 等价于 struct Student st;
    St *ss; // St *ss等价于struct Student *ss;
    return 0;
}
```

2、

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1guxvnhj1sgj60nk0fat9y02.jpg" alt="image-20210929224121153" style="zoom:50%;" /> 

```c
#include<stdio.h>

typedef struct Student{
    int sid;
    char name[100];
    char sex;
}*St; // *St 等同于struct Student *

int main(){   
    return 0;
}
```

3、

![image-20210929224553171](https://tva1.sinaimg.cn/large/008i3skNgy1guxvs7qj1ej61j70u0gp702.jpg)



### **（1）定义**



> 1、N个节点离散的
>
> 2、彼此通过指针项链
>
> 3、每一个节点只可能有一个前驱节点，每个节点后面只可能有一个后驱节点。收节点没有前驱节点，尾结点没有后驱节点



**专业术语：**



![image-20210929230911045](https://tva1.sinaimg.cn/large/008i3skNgy1guxwgf3wunj61h00c440f02.jpg)

> **首节点 ：**第一个有效节点
>
> **尾结点：**最后一个有效节点
>
> **头结点：**==第一个有效节点之前的节点==
>
> ​			  ==头结点并不存放有效数据==
>
> ​	   	   ==加头结点的目的主要是为了方便对链表的操作==
>
> ​		      ==头结点的数据类型和首结点一样==
>
> **头指针：**指向头结点的指针变量
>
> **尾指针:**指向尾结点的指针变量

  

**我们确定一个链表需要几个参数？？？？**

==只需要一个参数：头指针，因为我们通过头指针可以推算出链表的其他所有信息==



### **（2）分类**

1、单链表

2、双链表：每一个节点有两个指针

3、循环链表：能通过任何一个节点找到其他所有的节点

4、非循环链表：

### **（3）算法**

> 算法有两个标准，一个是广义的，一个是狭义的，从狭义的讲，算法跟数据的存储是有关系的，广义的讲，则
>
> 是无关的。
>
> 泛型：
>
> 利用某种技术达到的效果就是：不同的存储方式，执行的操作是一样的

 注：狭义与广义区别

- 狭义：从内部的真正实现上说
- 广义：



**==怎么学算法？==**

涉及数学相关，把答案拿出来，把答案看懂！

**如何将一个程序（答案）由不懂到看懂？**

- 流程
- 每个语句的功能
- 试错

1、遍历

2、查找

3、清空

4、销毁

5、求长度

6、排序

7、删除节点

....



>  自创链表

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1guyqahqdjmj61260ii3zv02.jpg" alt="image-20210930162128660" style="zoom:50%;" />  

```c
#include<stdio.h>
#include<mm_malloc.h>

typedef struct Node{
    int data; //数据域
    struct Node *pNext;
}NODE,*PNODE;

//声明函数
PNODE create_list();
void traverse_list(PNODE pHead);
bool is_empty(PNODE pHead);
int getLenght(PNODE pHead);
bool insert_list(PNODE pHead,int pos,int val);
bool deleteList(PNODE pHead,int pos,int *val); // 第三个参数用于存储被删链表的数值
void softList(PNODE pHead); //排序
bool insertList(PNODE pHead,int pos,int val); //链表插入 ,pos从1开始
bool deleteList(PNODE pHead,int pos,int *pVal); 

int main(){
    PNODE pHead = NULL; //  等价于struct Node *pHead = NULL;
    pHead = create_list(); //create_list()功能： 创建一个非循环单链表，并将该链表的头结点的地址赋给pHead
    traverse_list(pHead);//traverse_list 遍历输出
    if (is_empty(pHead))
    {
        printf("链表为空!\n");
    }else{
        printf("链表不为空！\n");
    }
    int len = getLenght(pHead);
    printf("链表长度为：%d\n",len);

    printf("\n-------------\n");

    //测试排序
    // softList(pHead);
    // traverse_list(pHead);


    printf("\n-------------\n");
    //测试插入
    // insertList(pHead,4,520);
    // traverse_list(pHead);

    printf("\n-------------\n");
    //测试删除
    int val;
    
    if (deleteList(pHead,4,&val))
    {
        printf("删除成功，该元素的值为:%d\n",val);
    }else{
        printf("删除失败，您好删除的元素不存在\n");
    }
    traverse_list(pHead);
    return 0;



}

PNODE create_list(){
    // 分配了一个不存放有效数据的头结点
    PNODE pHead =  (PNODE)malloc(sizeof(NODE));//  
    if(NULL == pHead){
        printf("分配失败，程序终止！");
        exit(-1);
    }

    PNODE pTail = pHead;
    pTail->pNext = NULL;


    int len;
    int i; // 用来存放用户有效输入节点的个数
    int val; // 用来临时存放用户输入的节点的值
    printf("请输入您需要生成链表节点的个数:len=");
    scanf("%d",&len);
    for(i=0; i<len; i++){
        printf("请输入第%d个节点的值：",i+1);
        scanf("%d",&val);
        PNODE pNew = (PNODE)malloc(sizeof(NODE));
        if(NULL == pHead){
            printf("分配失败，程序终止！");
            exit(-1);
       }
       pNew->data=val;
    //    将生成的节点挂到pHead头指针上，如何挂？方法如下
        pTail->pNext = pNew;
        pNew->pNext = NULL;
        pTail = pNew;//  pTail指向将pNew所在结构体对象的地址
    }
    return pHead;
}

void traverse_list(PNODE pHead){
    // 遍历输出
    PNODE p = pHead->pNext;
    while (p!= NULL)
    {

        printf("%d ",p->data);
        p = p->pNext;
    }
    printf("\n");
    return;
}

bool is_empty(PNODE pHead){
    if (pHead->pNext==NULL)
    {
        return true;
    }else{
        return false;
    }
    
}


int getLenght(PNODE pHead){
    int len = 0;
    // 遍历输出
    PNODE p = pHead->pNext;
    while (p!= NULL)
    {

        len++;
        p = p->pNext;
    }
    return len;  
}

// bool insert_list(PNODE pHead,int pos,int val);

 //冒泡排序
 /*
 
 */
void softList(PNODE pHead){
    int i,j;
    int temp;
    int len =getLenght(pHead);
    PNODE p,q;
    for (i=0,p=pHead->pNext; i<len-1; i++,p=p->pNext) // 外层循环，6个数，只需要比较5次
    {
        for(j=i+1,q=p->pNext; j<len; j++,q=q->pNext){
            if(p->data>q->data){ //类使用数组中a[i]>a[j]
                temp = p->data;
                p->data =q->data;
                q->data = temp;
            }
        }
    }
    return;
}

// 在pHead所指向链表的第pos个节点的前面插入一个新的节点，该节点的值为val，并且pos的值是从1开始
bool insertList(PNODE pHead,int pos,int val){
    //pos的范围是否合法
    int i = 0;
    PNODE p = pHead;

    while (p!=NULL && i <pos-1) //这个循环的目的是让p指向pos的前面一个节点
    {
        p = p->pNext; // 最终p会指向
        i++;
    }
    if (p==NULL || i >pos-1)
    {
       return false;
    }

    PNODE pNew =  (PNODE)malloc(sizeof(NODE));
    if(NULL == pNew){
        printf("分配失败，程序终止！");
        exit(-1);
    }
    pNew->data=val; //值存入
    //开始插入
    PNODE q = p->pNext; //q为中间变量
    p->pNext = pNew;
    pNew->pNext=q;
    return true;
    /*
    这三行为核心代码-详细分析可以看下方流程图
    PNODE q = p->pNext; //q为中间变量
    p->pNext = pNew;
    pNew->pNext=q;
    */
}


bool deleteList(PNODE pHead,int pos,int *pVal){
   
    //pos的范围是否合法
    int i = 0;
    PNODE p = pHead;

    while (p->pNext!=NULL && i <pos-1) //这个循环的目的是让p指向pos的前面一个节点
    {
        p = p->pNext; // 最终p会指向
        i++;
    }
    if (NULL==p->pNext || i >pos-1)
    {
       return false;
    }
    //接受被删除节点所存储的数值
    *pVal = p->pNext->data;
    //开始删除
    PNODE q = p->pNext; // 先将要删除的元素存起来，以便后面释放空间
    p->pNext = p->pNext->pNext; // 所谓删除，就是将p指向要删除的元素的后面一个，然后将p的空间释放
    free(p);

}
```



插入3行代码分析：

![image-20210930171342261](https://tva1.sinaimg.cn/large/008i3skNgy1guyrsvusnij617g0u00wh02.jpg)







### **（4）循环链表**

> **定义：一种头尾相连的链表（即：表中最后一个节点的指针域指向头结点，整个链表形成了一个环）**



![image-20211031113824024](https://tva1.sinaimg.cn/large/008i3skNgy1gvycbjmuluj31gc0aa0th.jpg)

==**优点：**==从表中的任一节点出发都能找到表中其他节点。



![image-20211031114354211](https://tva1.sinaimg.cn/large/008i3skNgy1gvych8gfkoj31pi0rwwip.jpg)



![image-20211031114533362](https://tva1.sinaimg.cn/large/008i3skNgy1gvyciyb3j1j31ax0u0q7e.jpg)





> **如何将==带尾指针==的两个循环链表合并？**

![image-20211031114826776](https://tva1.sinaimg.cn/large/008i3skNgy1gvyclyczpdj31660fs0ue.jpg)

**分析一下有哪些操作？**

![image-20211031115516866](https://tva1.sinaimg.cn/large/008i3skNgy1gvyct7jw4kj31bi0i0dhx.jpg)

(1)、先保留Ta的头结点：`p = Ta->next`

(2)、将Ta表的表尾接到Tb表的第一个有效节点：`Ta->next =Tb->next->next;` 

(3)、释放Tb表的头结点：`free(Tb->next)；delete Tb->next;`

(4)、Tb表的尾结点指向Ta表的头结点：`Tb->next =p`







### **（5）双向链表**

**1、定义：在单链表的每个节点里增加一个指向其直接前驱的指针域prior，这样链表中形成了有两个方向不同的链，故称为双向链表。**

**2、结构：**

![image-20211031120304618](https://tva1.sinaimg.cn/large/008i3skNgy1gvyd16o0n2j31l60j60ve.jpg)

![image-20211031120642826](https://tva1.sinaimg.cn/large/008i3skNgy1gvyd4yzum8j31pa0d6gmn.jpg)

![image-20211031120707995](https://tva1.sinaimg.cn/large/008i3skNgy1gvyd5eoncbj31dm094jsk.jpg)

![image-20211031120731291](https://tva1.sinaimg.cn/large/008i3skNgy1gvyd5t4xirj30ug0aamxh.jpg)



> 双向链表的插入

![image-20211031123841562](https://tva1.sinaimg.cn/large/008i3skNgy1gvye28l89dj31at0u0q5s.jpg)





### **（6）双向循环链表**

![image-20211031120849293](https://tva1.sinaimg.cn/large/008i3skNgy1gvyd75zg84j31o40lm77m.jpg)



### **（7）顺序表与链表的比较**

**一、链表的优缺点：**

**优点：**

==1、节点空间可以动态申请和释放==

==2、删除和插入操作的时候只需要修改指针，而不需要移动元素==

**缺点：**

==3、存储密度小，原因是每个节点在存储数据本身的同时，还需要额外的存储它的后续节点和前驱节点的地址，占用的空间比较大==

![image-20211031125225020](https://tva1.sinaimg.cn/large/008i3skNgy1gvyegifr3dj31b20iu76f.jpg)

==4、非随机存取结构，时间复杂度就提高了==

> **什么是随机存取？**

**即：任意一个元素都可以通过下表获取到**





![image-20211031125627433](https://tva1.sinaimg.cn/large/008i3skNgy1gvyekqhwkzj31g20u0wmp.jpg)



### **（8）线性表的应用**

> 1、线性表的合并

![image-20211031130226247](https://tva1.sinaimg.cn/large/008i3skNgy1gvyeqy4httj31ou0f2mzi.jpg)

![image-20211031145213600](https://tva1.sinaimg.cn/large/008i3skNgy1gvyhx6j83kj30yg0fswg0.jpg)



**实现方式：**

![image-20211031145556215](https://tva1.sinaimg.cn/large/008i3skNgy1gvyi11kel3j31c60oodm6.jpg)



> 2、有序线性表的合并

![image-20211031130331696](https://tva1.sinaimg.cn/large/008i3skNgy1gvyes2xdiuj31ne0fegos.jpg)

==为什么是**非递减**有序排序？==

因为可能存在重复元素

![image-20211031145935287](https://tva1.sinaimg.cn/large/008i3skNgy1gvyi4u8vdkj31me0fugoi.jpg)

**顺序表实现有序表的合并：**

![image-20211031150323091](https://tva1.sinaimg.cn/large/008i3skNgy1gvyi8sloxjj31p60oo0zg.jpg)

![image-20211031150549326](https://tva1.sinaimg.cn/large/008i3skNgy1gvyibbvnmsj31oe0o6dkq.jpg)

![image-20211031150712673](https://tva1.sinaimg.cn/large/008i3skNgy1gvyicrsbz1j31fw04i0tr.jpg)

![image-20211031150754289](https://tva1.sinaimg.cn/large/008i3skNgy1gvyidi138nj31em04cgmo.jpg)



**链表实现有序表合并**

![image-20211031151603543](https://tva1.sinaimg.cn/large/008i3skNgy1gvyilzayzej31ku0okn02.jpg)



![image-20211031151647172](https://tva1.sinaimg.cn/large/008i3skNgy1gvyimqglvxj31ne0tadk7.jpg)



![image-20211031151707522](https://tva1.sinaimg.cn/large/008i3skNgy1gvyin3hwiqj31j40s40vw.jpg)



![image-20211031151933666](https://tva1.sinaimg.cn/large/008i3skNgy1gwbctsxtv1j31me0r841w.jpg)

![image-20211031152144203](https://tva1.sinaimg.cn/large/008i3skNgy1gvyirvueagj31kc04u0ty.jpg)

==注：最坏情况就是La和Lb一样长，所有的都要执行完，所有时间复杂度是最大为👆🏻==





### **（9）案例一：一元多项式的运算**

![image-20211031153122241](https://tva1.sinaimg.cn/large/008i3skNgy1gvyj1wxze9j31db0u079s.jpg)



![image-20211031153044384](https://tva1.sinaimg.cn/large/008i3skNgy1gvyj19k5q6j31l80u00x0.jpg)



### **（10）案例二：稀疏多项式的运算**

**1、顺序存储实现**

![image-20211031153437842](https://tva1.sinaimg.cn/large/008i3skNgy1gvyj5b9jo3j31ll0u0n4k.jpg)



![image-20211031153739144](https://tva1.sinaimg.cn/large/008i3skNgy1gvyj8g4809j31n20u07bl.jpg)

使用顺序表进行存储的问题：**==

1、不带好确定分配多大的空间进行存储，**存储空间分配不灵活**

2、需要新建立一个数组，**空间复杂度高**

==**怎么解决以上问题？**==

答：采用链表进行存储



**2、链式存储实现**

![image-20211031154247002](https://tva1.sinaimg.cn/large/008i3skNgy1gvyjdsggcgj31bj0u0n3j.jpg)

![image-20211031154438085](https://tva1.sinaimg.cn/large/008i3skNgy1gvyjfpseahj31on0u0q9p.jpg)



**创建多项式代码**

![image-20211031154709067](https://tva1.sinaimg.cn/large/008i3skNgy1gvyjicb7sej31oh0u0gsy.jpg)

![image-20211031155110871](https://tva1.sinaimg.cn/large/008i3skNgy1gvyjmj2gnaj31550u00w7.jpg)

**多项式相加算算法**

![image-20211031155516234](https://tva1.sinaimg.cn/large/008i3skNgy1gvyjqs9t3vj31oy0tm11z.jpg)







### **（11）案例三：实现图书管理系统**

![image-20211031155642936](https://tva1.sinaimg.cn/large/008i3skNgy1gvyjsafr0aj30yc0tun47.jpg)

![image-20211031155811375](https://tva1.sinaimg.cn/large/008i3skNgy1gvyjttknk1j31jj0u0gpb.jpg)

![image-20211031155938486](https://tva1.sinaimg.cn/large/008i3skNgy1gvyjvbycj3j31ne0ssgqp.jpg)





![image-20211113151058482](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211113183742.png)

## 3、栈

### **（1）定义**

**一种可以实现“先进后出” 或者 "后进先出"的存储结构**



![image-20211031165037681](https://tva1.sinaimg.cn/large/008i3skNgy1gvylcf0zj2j31ge0t00xc.jpg)

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvylh5r0q7j30au0a4mxa.jpg" alt="image-20211031165512911" style="zoom:50%;" />   

**答：不可能有cab，因为如果c入栈了的话，a、b必然也已经入栈了**

只可能为：c-b-a







### **（2）代码实现相关算法**

> 1、顺序栈的实现

![image-20211031181200409](https://tva1.sinaimg.cn/large/008i3skNgy1gvynp2cyjhj31to0tugsw.jpg)

![image-20211031181722576](https://tva1.sinaimg.cn/large/008i3skNgy1gvynun67zhj31a40u0dke.jpg)



![image-20211031181948290](https://tva1.sinaimg.cn/large/008i3skNgy1gvynx65jv3j31jy0u0tex.jpg)



![image-20211031182049852](https://tva1.sinaimg.cn/large/008i3skNgy1gvyny8jqxvj31qa0pcwlt.jpg)



**顺序栈的代码实现**



![image-20211031182822752](https://tva1.sinaimg.cn/large/008i3skNgy1gvyo639utyj31360o6q6p.jpg) 

![image-20211031183013502](https://tva1.sinaimg.cn/large/008i3skNgy1gvyo80qxaqj31jv0u0432.jpg)



**顺序栈的初始化**

![image-20211031183333562](https://tva1.sinaimg.cn/large/008i3skNgy1gvyobhmr8lj31pw0u0dne.jpg)



**判断顺序栈是否为空**

![image-20211031183408382](https://tva1.sinaimg.cn/large/008i3skNgy1gvyoc2zwl4j31rs0p042y.jpg)

**求顺序栈的长度**

![image-20211031183454301](https://tva1.sinaimg.cn/large/008i3skNgy1gvyocvi7bjj31gc0kw41m.jpg)



**清空顺序栈**

![image-20211031183638964](https://tva1.sinaimg.cn/large/008i3skNgy1gvyoep4255j31n40lg0wl.jpg)

==注：前提if(S.base)是提前判断栈是否为空，如果已经为空，就没必要继续下面的操作了==



**顺序栈的销毁**

![image-20211031184010407](https://tva1.sinaimg.cn/large/008i3skNgy1gvyoid7na3j31ls0sutcn.jpg)





顺序栈入栈/压栈

![image-20211031184415592](https://tva1.sinaimg.cn/large/008i3skNgy1gvyomme7rhj31nm0u0tfd.jpg)



**顺序栈出栈**

![image-20211031184946663](https://tva1.sinaimg.cn/large/008i3skNgy1gvyoscugr1j31my0u0ah2.jpg)





> 2、链式栈的实现

![image-20211031185332929](https://tva1.sinaimg.cn/large/008i3skNgy1gvyowabb6rj31pe0u0q9p.jpg)



**初始化栈**

![image-20211031185533050](https://tva1.sinaimg.cn/large/008i3skNgy1gvyoyd1xz3j311q0petbf.jpg)



**判断链栈是否为空**

![image-20211031185630377](https://tva1.sinaimg.cn/large/008i3skNgy1gvyozcp9f7j30xc0kewgy.jpg)



**链栈的插入**

![image-20211031185910451](https://tva1.sinaimg.cn/large/008i3skNgy1gvyp24v3ekj31qc0tugry.jpg)

![image-20211031190632939](https://tva1.sinaimg.cn/large/008i3skNgy1gvyp9t7myoj31q40u0wm8.jpg)







**1、initStack(); 初始化栈：使得pTop，pBottom都指向一个无用的头结点，这就造出一个空栈了**

```c
void initStack(PSTACK pS){
   pS->pTop = (PNODE)malloc(sizeof(NODE)); //创建一个空节点(PNODE)malloc(sizeof(NODE))
     if (NULL == pS->pTop)
   {
      printf("动态内存分配失败");
      exit(-1);
   }else{
      pS->pBottom = pS->pTop; // 使得pTop与pBottom都指向它
      pS->pTop->pNext = NULL; // pS->pBottom->pNext = NULL; 并且将其值置为空
   }
}
```

![image-20211004171213443](https://tva1.sinaimg.cn/large/008i3skNgy1gv3e8ivfyzj60pk0cujrp02.jpg)



**2、出栈**

```c
// 把pS所指向的栈出栈一次，并把出栈的元素存储pVal这个形参所指向的变量中，如果出栈失败，返回false，否则返回true；
bool popStack(PSTACK pS,int *pVal){
   if (empt(pS))
   {
      return false;
   }else{
      // 出栈===（删除、保存删除节点的值到pVal这个形参所指向的变量中）
      PNODE r = pS->pTop;
      *pVal = r->data;
      pS->pTop = r->pNext;
      free(r);
      r = NULL;
      return true;
   }
} 
```



**3、压栈**

pushStack()实现

```c
void pushStack(PSTACK pS,int val){
   PNODE pNew = (PNODE)malloc(sizeof(NODE));
   pNew->data = val; 
   pNew->pNext = pS->pTop; //pS->Top 不能改成pS->Bottom
   pS->pTop = pNew;
   return;
}
```



![image-20211004172242357](https://tva1.sinaimg.cn/large/008i3skNgy1gv3ejfqebgj60lo0au74i02.jpg)   



**4、traverse遍历**

```c
void traverse(PSTACK pS){
   PNODE p = pS->pTop;
   while (p!=pS->pBottom)
   {
      printf("%d ",p->data);
      p = p->pNext;
   }
   printf("\n");
   return;
}
```

**5、clear()清空**

```c
//清空栈
void clear(PSTACK pS){

   if (empt(pS))
   {
      return ;
   }else{
      PNODE p = pS->pTop;
      PNODE q = NULL;
      while (p != pS->pBottom)
      {
         q = p->pNext;
         free(p);
         p = q;
      }
      pS->pTop = pS->pBottom; // 清空后结果
   }
}
```



> 自定义栈完整代码及实现

```c
#include<stdio.h>
#include<mm_malloc.h>

/**
 栈实现
 */

typedef struct Node{
   int data;
   struct Node *pNext;
}NODE,*PNODE; 


typedef struct Stack{
   PNODE pTop; //顶部
   PNODE pBottom; // 底部
}STACK,*PSTACK;


void initStack(PSTACK); // 初始化栈
void pushStack(PSTACK,int); // 压栈
void traverse(PSTACK); // 遍历输出
bool popStack(PSTACK,int *);// 出栈
bool empt(PSTACK); // 是否为空
void clear(PSTACK); //清空

int main(){

   STACK S; // 等价于 struct Stack S；
   initStack(&S); // 初始化栈:造出一个空栈
   pushStack(&S,1); // 压栈
   pushStack(&S,2);
   pushStack(&S,3); // 压栈
   pushStack(&S,4);
   pushStack(&S,5); // 压栈
   pushStack(&S,6);   
   traverse(&S); // 遍历输出
   /*
   printf("\n---------------------\n");
   int val;
   if (popStack(&S,&val))
   {
      printf("出栈成功，出栈的元素是：%d\n",val);
   }else
   {
       printf("出栈失败！\n");
   }

   */
   //测试清空函数
   clear(&S);
   traverse(&S); // 遍历输出

   return 0; 
}

void initStack(PSTACK pS){
   pS->pTop = (PNODE)malloc(sizeof(NODE));
   if (NULL == pS->pTop)
   {
      printf("动态内存分配失败");
      exit(-1);
   }else{
      pS->pBottom = pS->pTop;
      pS->pTop->pNext = NULL; // pS->pBottom->pNext = NULL;
   }
   
}

void pushStack(PSTACK pS,int val){
   PNODE pNew = (PNODE)malloc(sizeof(NODE));
   pNew->data = val; 
   pNew->pNext = pS->pTop; //pS->Top 不能改成pS->Bottom
   pS->pTop = pNew;
   return;
}

void traverse(PSTACK pS){
   PNODE p = pS->pTop;
   while (p!=pS->pBottom)
   {
      printf("%d ",p->data);
      p = p->pNext;
   }
   printf("\n");
   return;
}

bool empt(PSTACK pS){
   if (pS->pBottom == pS->pTop)
   {
      return true;
   }else{
      return false;
   }
   
}
// 把pS所指向的栈出栈一次，并把出栈的元素存储pVal这个形参所指向的变量中，如果出栈失败，返回false，否则返回true；
bool popStack(PSTACK pS,int *pVal){
   if (empt(pS))
   {
      return false;
   }else{
      // 出栈===（删除、保存删除节点的值到pVal这个形参所指向的变量中）
      PNODE r = pS->pTop;
      *pVal = r->data;
      pS->pTop = r->pNext;
      free(r);
      r = NULL;
      return true;
   }
} 

//清空栈
void clear(PSTACK pS){

   if (empt(pS))
   {
      return ;
   }else{
      PNODE p = pS->pTop;
      PNODE q = NULL;
      while (p != pS->pBottom)
      {
         q = p->pNext;
         free(p);
         p = q;
      }
      pS->pTop = pS->pBottom; // 清空后结果
   }
}
```



### **（3）应用-进制转换**

![image-20211031170654179](https://tva1.sinaimg.cn/large/008i3skNgy1gvyltbf4zzj31o80rqq7d.jpg)

![image-20211031170951562](https://tva1.sinaimg.cn/large/008i3skNgy1gvylwdrjucj30o20hqdgs.jpg)



> 思路

![image-20211031171119493](https://tva1.sinaimg.cn/large/008i3skNgy1gvylxx6se1j31800r8tca.jpg)



### **（4）应用-表达式括号匹配的检验**

![image-20211031171849476](https://tva1.sinaimg.cn/large/008i3skNgy1gvym5poqfxj31ir0u00y2.jpg)

**栈的规则：先入栈的括号后匹配，后入栈的括号先匹配**



### **（5）应用-表达式求值**

![image-20211031172240786](https://tva1.sinaimg.cn/large/008i3skNgy1gvym9qqbcaj31q80qyq9c.jpg)

![image-20211031175653657](https://tva1.sinaimg.cn/large/008i3skNgy1gvyn9dg1xhj31gs0u045o.jpg)





## 4、队列

### **（1）定义：**

是一种可以实现“先进先出”的存储结构！类似于：排队买票



![image-20211031170120052](https://tva1.sinaimg.cn/large/008i3skNgy1gvylnionthj31sy0tiwm2.jpg)



![image-20211031193331190](https://tva1.sinaimg.cn/large/008i3skNgy1gvyq1vxkncj31l30u0q89.jpg)



### **（2）相关术语**

![image-20211031193539995](https://tva1.sinaimg.cn/large/008i3skNgy1gvyq43pg43j31l70u044w.jpg)



![image-20211031193739984](https://tva1.sinaimg.cn/large/008i3skNgy1gvyq66nbtbj31m50u0122.jpg)







### **（3）顺序队列的实现**

![image-20211031194121214](https://tva1.sinaimg.cn/large/008i3skNgy1gvyqa0rfcvj31kg0u0dm8.jpg)



**初始化时候：**

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvyqbfa6l3j30gw0uwdh5.jpg" alt="image-20211031194241990" style="zoom:50%;" /> 

  

**有元素入队了：**

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvyqd7avd0j311x0u0tbw.jpg" alt="image-20211031194424783" style="zoom: 50%;" />    

有元素出队了：

![image-20211031194628482](https://tva1.sinaimg.cn/large/008i3skNgy1gvyqfcjrlqj31if0u0q82.jpg)



![image-20211031195112372](https://tva1.sinaimg.cn/large/008i3skNgy1gvyqkbc5n6j31h00u044t.jpg)



**引入循环队列**

![image-20211031195347627](https://tva1.sinaimg.cn/large/008i3skNgy1gvyqmz0f5gj31jz0u0tfq.jpg)

**解决插入时候假上溢问题**

![image-20211101085050753](https://tva1.sinaimg.cn/large/008i3skNgy1gvzd3hjhk9j321y0ridmg.jpg)



**解决删除时候假溢问题**

![image-20211101085442967](https://tva1.sinaimg.cn/large/008i3skNgy1gvzd7icyv7j31my0aujtv.jpg)



**类似于实现循环队列的效果**

![image-20211101085603629](https://tva1.sinaimg.cn/large/008i3skNgy1gvzd8x1rsvj313y0tw762.jpg)



**如何判断队空和堆满**

![image-20211101085843812](https://tva1.sinaimg.cn/large/008i3skNgy1gvzdbp75ivj31cu0u0796.jpg)



==方式一：另外设置一个标志以判断是队空还是队满==

==方式二：另设一个count用于统计个数==

==方式三：少用一个元素空间==





**采取方式三实现如下：**

![image-20211101090210451](https://tva1.sinaimg.cn/large/008i3skNgy1gvzdfa2vkoj31au0u0n1m.jpg)



![image-20211101090405923](https://tva1.sinaimg.cn/large/008i3skNgy1gvzdhac51zj31l90u0wm2.jpg)



> 代码实现：

0、结构体



![image-20211031194121214](https://tva1.sinaimg.cn/large/008i3skNgy1gvzdlfyyzxj31kg0u0q9c.jpg)

1、初始化操作

![image-20211101090708733](https://tva1.sinaimg.cn/large/008i3skNgy1gvzdkgh6p6j31mz0u00zl.jpg)

2、求队列的长度

![image-20211101091153025](https://tva1.sinaimg.cn/large/008i3skNgy1gvzdpdesiyj31rr0u0q91.jpg)

3、循环队列的入队算法

![image-20211101091422356](https://tva1.sinaimg.cn/large/008i3skNgy1gvzdrz0zi1j31t40syn3w.jpg)



4、循环队列的出队算法

```c
a、先判断是否为空，为空则不能进行出队操作

b、保留被删除的元素

c、对头指针+1
```

![image-20211101091718001](https://tva1.sinaimg.cn/large/008i3skNgy1gvzdv0tldoj31pa0t2n3k.jpg)



5、取出对头元素

```c
a、前提：队列不能为空
b、直接取出front所在位置的数值

```

![image-20211101091901420](https://tva1.sinaimg.cn/large/008i3skNgy1gvzdwt5irsj31ku0s443h.jpg)





### **（4）链式队列的实现**

![image-20211101092430478](https://tva1.sinaimg.cn/large/008i3skNgy1gvze2idrfej31sc0u07bi.jpg)



![image-20211101092644765](https://tva1.sinaimg.cn/large/008i3skNgy1gvze4uk5zej31k00u0q6v.jpg)



1、链式队列的初始化

![image-20211101092936802](https://tva1.sinaimg.cn/large/008i3skNgy1gvze7tp40xj31kn0u0te4.jpg)

2、链式队列的销毁

方式1：再定义一个指针变量p用于接收

![image-20211101093401241](https://tva1.sinaimg.cn/large/008i3skNgy1gvzecem81kj31in0u0dmz.jpg)

方式2：直接用Q.rear接收，节省空间

![image-20211101093612116](https://tva1.sinaimg.cn/large/008i3skNgy1gvzeeomahcj31mb0u0q9d.jpg)



3、链式队列的入队

![image-20211101093849204](https://tva1.sinaimg.cn/large/008i3skNgy1gvzeheemnfj31bu0u0gqb.jpg)



4、链队列的出队

![image-20211101094100526](https://tva1.sinaimg.cn/large/008i3skNgy1gvzejp8rn0j31bo0u0adc.jpg)



![image-20211101094344052](https://tva1.sinaimg.cn/large/008i3skNgy1gvzemjbksfj313c0u0q8o.jpg)



5、获取链队的队列元素

![image-20211101184814480](https://tva1.sinaimg.cn/large/008i3skNgy1gvzud3ugvrj31ec0o4whw.jpg)





静态队列都必须是循环队列

分析：

> 1、为什么静态队列必须是循环队列？
>
> 因为静态队列是基于数组实现的,如果不用循环队列,会导致删除的元素所使用的空间无法继续使用,造成空间的浪费



> 2、循环队列需要几个参数来确定
>
> 答：需要两个参数来确定，这2个参数在不同场合有不同的含义（先记住，再去慢慢体会它）
>
> `front`
>
> `rear`





> 3、循环队列的各个参数的含义
>
> 这2个参数在不同场合有不同的含义（先记住，再去慢慢体会它）
>
> ​	a、初始化：front与rear的值都为零
>
> ​	b、队列非空：front代表队列的第一个元素，rear代表队列的最后一个有效元素的下一个元素
>
> ​	c、队列空：front与rear的值相等但不一定是零



> 4、循环队列入队伪算法讲解

两步完成：

（1）、将值存入r所代表的位置

（2）、错误的写法rear=rear+1

​				 正确写法：rear=(rear + 1)%数组的长度

![image-20211008081030067](https://tva1.sinaimg.cn/large/008i3skNgy1gv7m1dtcexj60tq0rygn202.jpg) 



> 5、循环队列出队伪算法讲解

（1）、先把出队的值保存起来

（2）、front = (front+1) % 数组长度





> 6、如何判断循环队列是否为空

If（front == rear）则该队列一定为空



> 7、如何判断循环队列是否已满

有两种方式

（1）、多增加一个标志参数，len-用于记录长度

（2）、少用一个元素，如果front和rear紧挨着，则队列已满

```c
if(front ==(rear+1)%数组长度){
  已满
}else{
  未满
}
```



> 队列的实现

```c
#include<stdio.h>
#include<mm_malloc.h>
/*
    队列
*/
typedef struct Queue{
    int * pBase;
    int front;
    int rear;
}QUEUE;

// 声明
void init(QUEUE *pQ); // 初始化
bool en_queue(QUEUE *pQ,int val);  //入队
bool out_queue(QUEUE *pQ,int *pVal);  //出队 *pVal用于保存出队的值 
void traverse_queue(QUEUE *pQ); // 遍历
bool full_queue(QUEUE *pQ); //判断是否已满


int main(){
    QUEUE Q; //  结构体变量
    init(&Q);
    en_queue(&Q,1);
    en_queue(&Q,2);
    en_queue(&Q,3);
    en_queue(&Q,4);
    en_queue(&Q,5);
    en_queue(&Q,6);
    en_queue(&Q,7);
    en_queue(&Q,8);
    traverse_queue(&Q);

    return 0;
}



void init(QUEUE *pQ){
    pQ->pBase = (int *)malloc(sizeof(int)*4); // 代表一个数组
    pQ->front = 0;
    pQ->pBase = 0;
}


bool full_queue(QUEUE *pQ){
    if ((pQ->rear+1) % 6 == pQ->front)
    {
        return true;
    }else
    {
        return false;
    }
}

bool en_queue(QUEUE *pQ,int val){
    if(full_queue(pQ)){
        return false;
    }else
    {
        pQ->pBase[pQ->rear] = val;  // 将val放入rear位置
        pQ->rear = (pQ->rear+1) % 6; // 将rear往后移动一个位置
        return true;
    }
}

void traverse_queue(QUEUE *pQ){
    // 从头部遍历，只要没指向r ，就往后遍历
    int i = pQ->front;
    printf("1111");
    while (i!= pQ->rear)
    {
        printf("2222");
        printf("%d ",pQ->pBase[i]);
        i = (i+1)%6 ;
    }
    return; 
}
```





### **（6）应用-舞伴问题**

![image-20211031175740807](https://tva1.sinaimg.cn/large/008i3skNgy1gvyna562o6j31pg0ia0y2.jpg)

![image-20211031180032503](https://tva1.sinaimg.cn/large/008i3skNgy1gvynd4itzvj31z00fcjun.jpg)









## 6、字符串

> 串（String） ---零个或多个任意**字符组成的有限序列**

![image-20211101185558833](https://tva1.sinaimg.cn/large/008i3skNgy1gvzul479nxj31c10u0q6f.jpg)

 

> **关于串的术语**
>
> **子串、真子串、主串、字符位置、子串位置、空格串、串相等**

![image-20211101185701895](https://tva1.sinaimg.cn/large/008i3skNgy1gvzum7ns5uj31j00nwdjk.jpg)



![image-20211101190248829](https://tva1.sinaimg.cn/large/008i3skNgy1gvzus89esgj31q80rk10d.jpg)



![image-20211101190446373](https://tva1.sinaimg.cn/large/008i3skNgy1gvzuu9m9dtj31jc0q2jv5.jpg)



> 案例引入

![image-20211101191026781](https://tva1.sinaimg.cn/large/008i3skNgy1gvzv06b17ej31p10u0akc.jpg)



> 串的定义、存储结构、算法及运算

![image-20211101191317728](https://tva1.sinaimg.cn/large/008i3skNgy1gvzv351mlaj31ja0u00xy.jpg)



![image-20211101191510789](https://tva1.sinaimg.cn/large/008i3skNgy1gvzv53u1cnj31580seq8o.jpg)



> 结构分析



![image-20211101191706048](https://tva1.sinaimg.cn/large/008i3skNgy1gvzv73dydkj31km0sadkh.jpg)





### **（1）串的存储方式**

> 1、串的顺序存储结构

![image-20211101191922418](https://tva1.sinaimg.cn/large/008i3skNgy1gvzv9giivfj31kk0qoq8t.jpg)



> 2、串的链式存储结构

![image-20211101192113982](https://tva1.sinaimg.cn/large/008i3skNgy1gvzvbe6ph2j31c60i4jtt.jpg)

**改进方式，在一个节点中放置多个字符。以克服其缺点**

![image-20211101192300000](https://tva1.sinaimg.cn/large/008i3skNgy1gvzvd8bgbzj31nw0u00za.jpg)



### **（2）串的==模式==匹配算法**

**算法目的：**确定**主串**中所含**子串（模式串）**第一次出现的位置（定位）

**算法应用：**搜索引擎、拼写检查、语言翻译、数据压缩

**算法种类：**

- BF算法（Brute-Force, 又称古典的、经典的、朴素的、穷举的）
- KMP算法（特点：速度快）



### **（3）BF算法**

![image-20211101193148124](https://tva1.sinaimg.cn/large/008i3skNgy1gvzvmeqnpcj31kw0ncgqr.jpg)

![image-20211101193749726](https://tva1.sinaimg.cn/large/008i3skNgy1gvzvso2r2mj31nc0u00yc.jpg)

![image-20211101193759309](https://tva1.sinaimg.cn/large/008i3skNgy1gvzvstmd2vj315k0lcgmf.jpg)



![image-20211101193815203](https://tva1.sinaimg.cn/large/008i3skNgy1gvzvt3kqxij312k0nw3ze.jpg)

![image-20211101193829303](https://tva1.sinaimg.cn/large/008i3skNgy1gvzvtcg2shj311u0pot9q.jpg)



![image-20211101193841078](https://tva1.sinaimg.cn/large/008i3skNgy1gvzvtjzcntj317y0rata3.jpg)



![image-20211101193921226](https://tva1.sinaimg.cn/large/008i3skNgy1gvzvu92o0yj31m60ryacz.jpg)



![image-20211101194150288](https://tva1.sinaimg.cn/large/008i3skNgy1gvzvwu6cg8j31it0u0gor.jpg)



![image-20211101194258965](https://tva1.sinaimg.cn/large/008i3skNgy1gvzvy0w8cgj31i80u0grt.jpg)

> 从头开始查找代码实现

![image-20211101194916517](https://tva1.sinaimg.cn/large/008i3skNgy1gvzw4lrtm1j31p80t0q8z.jpg)

> 从指定位置开始查找代码实现

![image-20211101195124408](https://tva1.sinaimg.cn/large/008i3skNgy1gwbctr3qv4j31ml0u0tdk.jpg)



![image-20211101202322467](https://tva1.sinaimg.cn/large/008i3skNgy1gvzx42j4kgj31bi0u00xb.jpg)





### **（4）KMP算法**

> 没搞懂

![image-20211104140008301](https://tva1.sinaimg.cn/large/008i3skNgy1gw32w9k29xj31dg09emzc.jpg)



![image-20211104141130611](https://tva1.sinaimg.cn/large/008i3skNgy1gw33824uutj31eq0u0dkq.jpg)



![image-20211104141305790](https://tva1.sinaimg.cn/large/008i3skNgy1gw339pdmwcj30z80u0dio.jpg)



![image-20211104143236476](https://tva1.sinaimg.cn/large/008i3skNgy1gw33u0zu45j319l0u0jui.jpg)



![image-20211104143252887](https://tva1.sinaimg.cn/large/008i3skNgy1gw33ud6noaj31nq0u0k2l.jpg)



### **（5）案例-病毒检测**

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw376tgpvuj30u010vwje.jpg" alt="image-20211104162842048" style="zoom:33%;" /> 



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw37agj45lj31110u0ac4.jpg" alt="image-20211104163212662" style="zoom:50%;" /> 



![image-20211104163241925](https://tva1.sinaimg.cn/large/008i3skNgy1gw37azffgdj31ul0u046m.jpg)

![image-20211104163306336](https://tva1.sinaimg.cn/large/008i3skNgy1gw37benwouj31px0u07f6.jpg)











## 7、数组

> 定义：按照一定格式排列的 具有相同类型的数据元素的集合

### **（1）一维数组**

![image-20211104143634919](https://tva1.sinaimg.cn/large/008i3skNgy1gw33y5928tj31js0pidjt.jpg)



### **（2）二维数组**

> 极其特殊：既可以看成线性结构，也可以看成非线性结构



![image-20211104144049762](https://tva1.sinaimg.cn/large/008i3skNgy1gw342l0hbvj31hd0u07bh.jpg)



![image-20211104144343430](https://tva1.sinaimg.cn/large/008i3skNgy1gw345kthtuj31is0u0afy.jpg)



![image-20211104144427731](https://tva1.sinaimg.cn/large/008i3skNgy1gw346cpbjzj319r0u044m.jpg)



![image-20211104144753581](https://tva1.sinaimg.cn/large/008i3skNgy1gw349xaiijj31rm0u0jxd.jpg)



![image-20211104144855184](https://tva1.sinaimg.cn/large/008i3skNgy1gw34azup3sj31ow0u0dlj.jpg)

![image-20211104145116729](https://tva1.sinaimg.cn/large/008i3skNgy1gw34dgn018j321r0u0dn7.jpg)



![image-20211104145333878](https://tva1.sinaimg.cn/large/008i3skNgy1gw34ftgqvej321y0psdm7.jpg)







### **（3）数组的顺序存储**



![image-20211104145537937](https://tva1.sinaimg.cn/large/008i3skNgy1gw34hyt8s3j31ws0u0afz.jpg)



![image-20211104145713675](https://tva1.sinaimg.cn/large/008i3skNgy1gw34jmrli6j31xj0u079n.jpg)





![image-20211104145957338](https://tva1.sinaimg.cn/large/008i3skNgy1gw34mgkrxyj31gg0okjvw.jpg)



![image-20211104150150788](https://tva1.sinaimg.cn/large/008i3skNgy1gw34og35cjj31qc0u0th2.jpg)



>  以行序为主序

![image-20211104150329588](https://tva1.sinaimg.cn/large/008i3skNgy1gw34q5oyz8j31hd0u0af0.jpg)





>  以列序为主序

![image-20211104150341826](https://tva1.sinaimg.cn/large/008i3skNgy1gw34qckjtfj31k90u0acu.jpg)



![image-20211104150528082](https://tva1.sinaimg.cn/large/008i3skNgy1gw34s7qdfaj31b90u0afz.jpg)



![image-20211104150823260](https://tva1.sinaimg.cn/large/008i3skNgy1gw34v8q0mqj31id0u043t.jpg)



![image-20211104151128901](https://tva1.sinaimg.cn/large/008i3skNgy1gw34yh1j6qj31o30u0gr4.jpg)



![image-20211104151150408](https://tva1.sinaimg.cn/large/008i3skNgy1gw34ytn6kcj31ox0u078b.jpg)



![image-20211104151410422](https://tva1.sinaimg.cn/large/008i3skNgy1gw3519lnpcj31mv0u0jy6.jpg)





#### 1、特殊矩阵的压缩存储

![image-20211104151826280](https://tva1.sinaimg.cn/large/008i3skNgy1gw355qonuzj31cc0u0q8x.jpg)



#### 2、对称矩阵

![image-20211104152058595](https://tva1.sinaimg.cn/large/008i3skNgy1gw358nch9nj31vk0qa796.jpg)



![image-20211104152332379](https://tva1.sinaimg.cn/large/008i3skNgy1gw35b22kd8j31ii0u0wk5.jpg)



![image-20211104152628190](https://tva1.sinaimg.cn/large/008i3skNgy1gw35e2uk2ij31km0u0q9t.jpg)



#### 3、三角矩阵

![image-20211104152842202](https://tva1.sinaimg.cn/large/008i3skNgy1gw35gdo4kkj31ko0u00yn.jpg)

![image-20211104153302708](https://tva1.sinaimg.cn/large/008i3skNgy1gw35kx3p01j31js0u0tf1.jpg)



![image-20211104153458717](https://tva1.sinaimg.cn/large/008i3skNgy1gw35mx0oikj31fq0q8td2.jpg)



#### 4、稀疏矩阵

> 三元组顺序表



![image-20211104153751632](https://tva1.sinaimg.cn/large/008i3skNgy1gw35pwy5vnj31i00u0qah.jpg)



![image-20211104153919600](https://tva1.sinaimg.cn/large/008i3skNgy1gw35rflxxmj31kw0u0gsz.jpg)



> 链式存储结构-十字链表

![image-20211104160927691](https://tva1.sinaimg.cn/large/008i3skNgy1gw36mvm6c4j31cr0u0n2k.jpg)





![image-20211104161212734](https://tva1.sinaimg.cn/large/008i3skNgy1gw36pnfeuxj312a0u0gnk.jpg)





## 8、广义表

![image-20211104161439554](https://tva1.sinaimg.cn/large/008i3skNgy1gw36s6mwrnj31oe0fyn04.jpg)



![image-20211104161757920](https://tva1.sinaimg.cn/large/008i3skNgy1gw36vn6rl4j31pz0u0tf8.jpg)



![image-20211104162039992](https://tva1.sinaimg.cn/large/008i3skNgy1gw36yfwhjmj31b40u0tcy.jpg)

![](https://tva1.sinaimg.cn/large/008i3skNgy1gw36zyvlo0j31jv0u0qap.jpg)

![image-20211104162252498](https://tva1.sinaimg.cn/large/008i3skNgy1gw370qgqgbj31e70u042e.jpg)



![](https://tva1.sinaimg.cn/large/008i3skNgy1gw3724keg8j31gt0u00zt.jpg)



> 广义表的基本运算

![image-20211104162709344](https://tva1.sinaimg.cn/large/008i3skNgy1gw3757amwoj31f70u0ted.jpg)






# 四、非线性结构

## 1、树



==待学习：==

==B树和B+树==

==B站上西北大学耿老师讲的树那一章的课程==



### **1）、树的定义**

> 定义： 1、有且只有一个称为根的节点
>
> ​			2、有若干个互不相交的子树，这些子树本身也是一棵树
>
> 
>
> 通俗定义：1、树是由节点和边组成
>
> ​				  2、每个节点只有一个父节点但可以有多个子节点
>
> ​				  3、但有一个节点例外，该节点没有父节点，此节点称为根节点



>专业术语 

- **节点**
  - 父节点
  - 子节点
- **子孙**
  - 堂兄弟
- **深度**：从**根节点**到**最底层节点**的层数称之为**深度  ---类似楼层**

- **叶子节点：**没有子节点的节点
- **非终端节点：**实际就是**非叶子节点**
- **根节点**
- **度 ：**子节点的个数称为度



### **2）、树分类**

1、一般树：任意一个子节点的个数都不受限制

2、二叉树：任意一个节点的子节点的个数最多是2个，且子节点的位置不可更改！

```c
二叉树的分类：
					1、一般二叉树
					2、满二叉树:在不增加树的层数前提下，无法再多添加一个节点的二叉树就是满二叉树
					3、完全二叉树：如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树他就是完全二叉树
```





3、森林：n个互不相交的**树**的集合





3）、树的存储

> 树的存储： 非线性-->线性

**（1）、二叉树的存储：**

1. 连续存储（完全二叉树）

2. 链式存储

（**2）、一般树的存储**

1. 双亲表示法

存指针域，找双亲容易，找孩子难

2. 孩子表示法



3. 双亲孩子表示法

求父节点和子节点都很方便

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw97cjnsu1j31cs0u0aif.jpg" alt="image-20211009145245757" style="zoom:50%;" />

1. 二叉树表示法

   把一个普通树转化成二叉树对存储

> 具体转换方法：
>
> 设法保证任意一个节点左指针域指向它的第一个孩子，右指针域指向它的兄弟，只要能满足此条件，就能把一个普通数转化成一个二叉树



### **3）、森林**



> 将树转化成二叉树

![image-20211104202443976](https://tva1.sinaimg.cn/large/008i3skNgy1gw3e0egz8sj31hh0u0dmn.jpg)

![image-20211104202826077](https://tva1.sinaimg.cn/large/008i3skNgy1gw3e48r3f9j31gd0u0gr6.jpg)

==口诀：==

![image-20211104202859993](https://tva1.sinaimg.cn/large/008i3skNgy1gw3e4th063j30w4062wfa.jpg)





> 二叉树转化成树



![image-20211104202938838](https://tva1.sinaimg.cn/large/008i3skNgy1gw3e5igffqj31dp0u0dll.jpg)

![image-20211104203101133](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cjz9xuj31ol0u0zps.jpg)







> 森林转成二叉树

![image-20211104203338148](https://tva1.sinaimg.cn/large/008i3skNgy1gw3e9nrwn9j31ps0u0ten.jpg)



![image-20211104203434118](https://tva1.sinaimg.cn/large/008i3skNgy1gw3eam0dgwj31nw0u042s.jpg)





> 二叉树转成森林

![image-20211104203801073](https://tva1.sinaimg.cn/large/008i3skNgy1gw3ee7y6p5j31rb0u0n39.jpg)

![image-20211104203922830](https://tva1.sinaimg.cn/large/008i3skNgy1gw3efn8vltj31rq0u0wjh.jpg)







>  森林的存储

先把森林转化为二叉树，再存储二叉树

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv952v1fj6j619e0u0grd02.jpg" alt="image-20211009162845825" style="zoom:67%;" /> 





### **4）、二叉树的遍历**

**1、先序遍历**

==先访问根节点==

==再先访问左子树==

==再先序访问右子树==

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv97vvbya4j60yy0u0jvu02.jpg" alt="image-20211009180549093" style="zoom:50%;" /> 

 



**2、中序遍历**

==中序遍历左子树==

==在访问根节点==

==再中序遍历右子树==

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw97ckbzi6j31050u0ady.jpg" alt="image-20211009181934388" style="zoom:50%;" /> 

**3、后序遍历**

==中序遍历左子树==

==中序遍历右子树==

==在访问根节点==

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv98omisnqj615f0u0jw402.jpg" alt="image-20211009183329478" style="zoom:50%;" /> 

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv98peutr6j617r0u0tbm02.jpg" alt="image-20211009183415061" style="zoom:50%;" /> 

**4、已知两种遍历序列求原始二叉树**

通过 先序+中序  or 中序+后续 可以唯一的还原一个二叉树

通过 先序+后续 无法实现还原二叉树





**5、先序+中序  --> 还原二叉树**

> 先序：ABCDEFGH
>
> 中序：BDCEAFHG
>
> 求后续？

例题一：

![image-20211009192132821](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cktw7fj31jn0u042m.jpg)

例题二：

![image-20211009192756678](https://tva1.sinaimg.cn/large/008i3skNgy1gw97ctb0igj31kn0u0n2x.jpg)



**5、中序+后序  --> 还原二叉树**

> 中序：BDCEAFHG
>
> 后序：BECBHGFA
>
> 求先续？

![image-20211009195922963](https://tva1.sinaimg.cn/large/008i3skNgy1gv9b694xj6j61ti0oe0xg02.jpg)



### **5）、树的应用**

1. 树是数据库中数据组织一种重要形式
2. 操作系统子父进程关系本身就是一颗树
3. 面向对象语言中的类的继承关系本身是一棵树
4. 赫夫曼树

 

### **6）、链式二叉树遍历代码实现**



```c
#include<stdio.h>
#include<mm_malloc.h>
struct BTNode
{
    int data;
    struct BTNode *pLchild; // p是指针  L是左  child是孩子
    struct BTNode *pRchild; // p是指针  R是右孩  child是孩子
};

struct BTNode * CreateBTree(){
    struct BTNode *pA = (struct BTNode *)malloc(sizeof(struct BTNode));
    struct BTNode *pB = (struct BTNode *)malloc(sizeof(struct BTNode));
    struct BTNode *pC = (struct BTNode *)malloc(sizeof(struct BTNode));
    struct BTNode *pD = (struct BTNode *)malloc(sizeof(struct BTNode));
    struct BTNode *pE = (struct BTNode *)malloc(sizeof(struct BTNode));
    pA->data = 'A';
    pB->data = 'B';
    pC->data = 'C';
    pD->data = 'D';
    pE->data = 'E';

    pA->pLchild = pB;
    pA->pRchild = pC;
    pB->pLchild = pB->pRchild =NULL;
    pC->pLchild =pD;
    pC->pRchild =NULL;
    pD->pLchild = NULL;
    pD->pRchild = pE;
    pE->pLchild = pE->pRchild = NULL;
    return pA;
}


void PreTraverseBTree(struct BTNode *pT){
    if (NULL != pT)
    {
         /*
        伪算法
        1、先根节点：pT
        2、再先左子树:pT->pLchild代表挣个左子树
        3、再先右子树
         */
        // 1、先根节点：pT
        printf("%c\n",pT->data);
        // 2、再先左子树
        if (NULL != pT->pLchild)
        {
            PreTraverseBTree(pT->pLchild);
        }
        
        // 3、再先右子树
        if (NULL != pT->pRchild)
        {
            PreTraverseBTree(pT->pRchild);
        }
    }
    
    

}

void InTraverseBTree(struct BTNode *pT){
    if (NULL != pT)
    {
        //1、先序遍历左子树
        if (NULL != pT->pLchild)
        {
            InTraverseBTree(pT->pLchild);
        }
        
        //2、访问根节点
        printf("%c\n",pT->data);

        //3、中序遍历右子树
        if (NULL != pT->pRchild)
        {
            InTraverseBTree(pT->pRchild);
        }
    }
    
}

void PostTraverseBTree(struct BTNode *pT){
  if (NULL != pT)
    {
        //1、先序遍历左子树
        if (NULL != pT->pLchild)
        {
            PostTraverseBTree(pT->pLchild);
        }
        //2、中序遍历右子树
        if (NULL != pT->pRchild)
        {
            PostTraverseBTree(pT->pRchild);
        }
        //3、访问根节点
        printf("%c\n",pT->data);
    }
}

int main(){

    struct BTNode *pT = CreateBTree(); // 创建二叉树
    // 非线性转话成线性才能输出，先序方式输出
    // PreTraverseBTree(pT); 
    // InTraverseBTree(pT); 
    PostTraverseBTree(pT); 

    return 0;
}
```



### **7）、二叉树遍历算法的应用**

> 中序遍历递归分析

![image-20211122132213852](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211122132214.png)



> 中序遍历的非递归方式

（1）、建立一个栈

（2）、根节点进栈，遍历左子树

（3）、根节点出栈，输出根节点，遍历右子树



![image-20211122132823554](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211122132823.png)



![image-20211122132858846](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211122132859.png)





![image-20211122132914640](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211122132914.png)



![image-20211122132953024](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211122132953.png)



![image-20211122133030954](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211122133031.png)





![image-20211122133047955](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211122133048.png)



![image-20211122133110650](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211122133111.png)



![image-20211122133126109](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211122133126.png)







> 复制二叉树

![image-20211104194515547](https://tva1.sinaimg.cn/large/008i3skNgy1gw3cvf3m6oj31m50u0jyd.jpg)



> 计算机二叉树的深度

![image-20211104194955794](https://tva1.sinaimg.cn/large/008i3skNgy1gw3d07ike8j31gy0u00zr.jpg)



> 计算二叉树的节点总个数

![image-20211104195559811](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cojpx6j31ix0u0jxm.jpg)

> 计算二叉树**叶子结点**总个数

![image-20211104200106719](https://tva1.sinaimg.cn/large/008i3skNgy1gw3dbuk5vdj31pv0u0ahf.jpg)



> 完整代码

```c
#include<stdio.h>
#include<mm_malloc.h>
typedef char dataType;
typedef struct BiTNode{
    dataType data;
    struct BiTNode *lchild;
    struct BiTNode *rchild;
}BiTNode,*BiTree;






// 创建二叉树(先序遍历)
void creatBiTree(BiTree &T){
    dataType ch;
    scanf("%c",&ch);
    if (ch == '#')
    {
       T=NULL;
    }else
    {
        T = (BiTNode*)malloc(sizeof(BiTNode)); //生成根节点
        T->data = ch; // 根节点数据域置位ch
        creatBiTree(T->lchild); //递归创建左子树
        creatBiTree(T->rchild); //递归创建右子树
    }
}

// 遍历输出(先序遍历)
void preShow(BiTree &T){
    if (T)
    {
        printf("%c ",T->data); // 遍历根节点
        preShow(T->lchild); // 遍历左子树
        preShow(T->rchild); // 遍历右子树
    }
}

// 遍历输出(中序遍历)
void midShow(BiTree &T){
    if (T)
    {   
        midShow(T->lchild); // 遍历左子树
        printf("%c ",T->data); // 遍历根节点
        midShow(T->rchild); // 遍历右子树
    }
}
// 遍历输出(后序遍历)
void postShow(BiTree &T){
    if (T)
    {  
        postShow(T->lchild); // 遍历左子树
        postShow(T->rchild); // 遍历右子树
        printf("%c ",T->data); // 遍历根节点
    }
}
/*
// 中序遍历(非递归算法) ---难点----
void midShow2(BiTree &T){   
    //创建一个栈
    initStack(S);
    BiTree p = T; // 定义一个指针，指向树的根
    BiTree q = (BiTNode*)malloc(sizeof(BiTNode)); //生成根节点
    while(p!=NULL || StackEmpty(S)){
        if(p=!NULL){
            push(S,p)//根指针进栈
            p = p->lchild;
        }else{
            pop(S,q){ //如果p为空，出栈一个节点，用q接收
                printf("%d ",q->val); // 打印输出值
                p = q.rchild;
            }
        }
    }
}

*/

// 深度（高度）
int getHight(BiTree &T){
    if(T==NULL){
        return 0;
    }
    int lLen = getHight(T->lchild);
    int rLen = getHight(T->rchild);
    return lLen>rLen?lLen+1:rLen+1; // 深度 = 左右子树中深度最大的+1

}
// 总结点数
int allSize(BiTree &T){
    if (T==NULL)
    {
        return 0;
    }else
    {
        return allSize(T->lchild)+allSize(T->rchild)+1;// 总结点数为：左子树节点总个数+右子树总节点 +1
    }
}

// 叶子节点
int leafSize(BiTree &T){
    if (T == NULL) // 树为空，返回0
    {
        return 0;
    }
    if (T->lchild == NULL && T->rchild ==NULL){ // 树的左子树与右子树都为空 返回1
        return 1;
    }
    return leafSize(T->lchild) + leafSize(T->rchild);// 其他情况递归运算求和
}

// 最大值
int max(BiTree &T){
    if (T == NULL)
    {
        return 0;
    }
    if (T->lchild == NULL && T->rchild ==NULL){ // 树的左子树与右子树都为空 返回1
        return T->data;
    }
    int maxL = max(T->lchild);
    int maxR = max(T->rchild);
    return maxL>maxR?maxL:maxR;
}

// 复制一颗相同的二叉树
void copy(BiTree &T,BiTree &newT){
    if (T==NULL)
    {
        newT = NULL;
        return; //程序终止
    }
    else
    {
        newT = (BiTNode*)malloc(sizeof(BiTNode)); // 分配空间
        newT->data = T->data;// 复制根节点的值
        copy(T->lchild,newT->lchild); //复制左子树
        copy(T->rchild,newT->rchild);// 复制右子树
    }
}

int main(){
    BiTree tree;
    printf("请按先序序列输入各节点字符，某节点的左子树或右子树为空时候，输入一个字符# \n");
    printf("如输入：ABD#G###CE##F##\n");
    creatBiTree(tree);
    printf("\n先序遍历结果为：");
    preShow(tree);

    printf("\n中序遍历结果为：");
    midShow(tree);

    printf("\n后序遍历结果为：");
    postShow(tree);

    printf("\n深度为：%d",getHight(tree));

    printf("\n叶子节点数：%d",leafSize(tree));

    printf("\n总结点数：%d",allSize(tree));

    printf("\n最大值：%c",max(tree));


    BiTree newTree;
    copy(tree,newTree); // 复制测试
    preShow(newTree);  // 复制后的结果先序输出

    return 0;
}

```



### **8）、线索二叉树**

（1）、定义

![image-20211027195926490](https://tva1.sinaimg.cn/large/008i3skNgy1gvu4bwd7a3j31hu0oygqy.jpg) 

（2）、案例演示

![image-20211027204104775](https://tva1.sinaimg.cn/large/008i3skNgy1gvu5ixvkg9j319x0u041s.jpg) 



（3）、标志域



![image-20211027204321912](https://tva1.sinaimg.cn/large/008i3skNgy1gvu5lbmefkj31lv0u0afp.jpg)

![image-20211027204425336](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cl99loj317y0sktc1.jpg)





> 练习题

![image-20211104201021559](https://tva1.sinaimg.cn/large/008i3skNgy1gw3dlft3hfj318p0u0tb5.jpg)



![image-20211104201041154](https://tva1.sinaimg.cn/large/008i3skNgy1gw3dlrvk0vj31k60u0dk8.jpg)



解决上述指向空的问题，采用增设一个头结点



![image-20211104201005385](https://tva1.sinaimg.cn/large/008i3skNgy1gw3dl5s3skj31i60u07b0.jpg)





### **9）、哈夫曼树**

![image-20211104204537363](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cm90aij31e40u0n7s.jpg)



> 引子

![image-20211104205200519](https://tva1.sinaimg.cn/large/008i3skNgy1gw3ess7itdj31mz0u00yx.jpg)



![image-20211104205224896](https://tva1.sinaimg.cn/large/008i3skNgy1gw3et7vcapj31h00u0tf9.jpg)



#### **（1）基本概念**

> 路径
>
> 节结点的路径长度

![image-20211104205500558](https://tva1.sinaimg.cn/large/008i3skNgy1gwbcts56d2j31o20u0dkq.jpg)



![image-20211104205515884](https://tva1.sinaimg.cn/large/008i3skNgy1gw3ew5n688j31o20u0q8v.jpg)

> 树的路径长度

![image-20211104205644813](https://tva1.sinaimg.cn/large/008i3skNgy1gw3expygyqj31ia0u0q8o.jpg)

**注意：完全二叉树不一定是最短路径，非完全二叉树也可成为最短路径**



> 权值
>
> 节点的带权路径长度

![image-20211104210031973](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cvj932j31p00hiq6e.jpg)





> 树的带权路径长度

![image-20211104210355559](https://tva1.sinaimg.cn/large/008i3skNgy1gw3f58ht7zj31rs0kwwih.jpg)



**带权二叉树的计算**

![image-20211104210627631](https://tva1.sinaimg.cn/large/008i3skNgy1gw3f7sv0qwj31hw0u043a.jpg)



#### （2）定义

![image-20211104211127874](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d19p59j31j20u0gsa.jpg)



![image-20211104211231818](https://tva1.sinaimg.cn/large/008i3skNgy1gw97clu0hjj31o00u0agg.jpg)

==结论：==

==1、满二叉树不一定是哈夫曼树==

==2、具有相同带权节点的哈夫曼树并不唯一==



#### **（3）构造哈夫曼树**

![image-20211104211951326](https://tva1.sinaimg.cn/large/008i3skNgy1gw3flrx39ij31nf0u045l.jpg)



![image-20211104212216327](https://tva1.sinaimg.cn/large/008i3skNgy1gw3foa0hl8j31rx0u046m.jpg)



![image-20211105072834882](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cnmn3aj31lt0u0n33.jpg)



![image-20211105073101945](https://tva1.sinaimg.cn/large/008i3skNgy1gw3x9oyvubj31he0u0qaw.jpg)



![image-20211105073324150](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cmo45rj31fb0u0afj.jpg)



![image-20211105073521654](https://tva1.sinaimg.cn/large/008i3skNgy1gw3xe6ptsej31rm0u0zqs.jpg)



#### **（4）哈夫曼树算法实现**

> 采用顺序存储结构-一维结构数组

![image-20211105073809252](https://tva1.sinaimg.cn/large/008i3skNgy1gw3xm8cssvj31la0u0n2i.jpg)





![image-20211105074216965](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cqul8hj312l0u0mzv.jpg)



![image-20211105074230346](https://tva1.sinaimg.cn/large/008i3skNgy1gw3xlm1bx0j312u0u0go8.jpg)



![image-20211105074245789](https://tva1.sinaimg.cn/large/008i3skNgy1gw3xlwr83uj313i0u0dil.jpg)



![image-20211105074600834](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cv3x2uj31350u0win.jpg)



初始化

![image-20211105074631136](https://tva1.sinaimg.cn/large/008i3skNgy1gw3xprxqhgj318y0d8ac5.jpg)

![image-20211105074742469](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cp2dq2j31ie0u0agm.jpg)



合并产生新节点

![image-20211105074841312](https://tva1.sinaimg.cn/large/008i3skNgy1gw3xs1fhp2j31v40n8n3p.jpg)

![image-20211105075059601](https://tva1.sinaimg.cn/large/008i3skNgy1gw3xug57s5j31pk0u0wlk.jpg)



> 例子

![image-20211105075216971](https://tva1.sinaimg.cn/large/008i3skNgy1gw97co390uj31bs0u0aev.jpg)



![image-20211105075230393](https://tva1.sinaimg.cn/large/008i3skNgy1gw97ctoj4nj31i20u0jvy.jpg)





#### **（5）哈夫曼编码**

![image-20211105075903036](https://tva1.sinaimg.cn/large/008i3skNgy1gw3y2ualmvj31oh0u0wjz.jpg)



![image-20211105080015438](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cn692ej31jg0u0442.jpg)



![image-20211105080115354](https://tva1.sinaimg.cn/large/008i3skNgy1gw3y5a70iej31lw0u0th3.jpg)



![image-20211105080612990](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d3jz7yj31bk0u043c.jpg)



![image-20211105080741645](https://tva1.sinaimg.cn/large/008i3skNgy1gw3ybtvpyrj31xm0t27ct.jpg)

![image-20211105080855214](https://tva1.sinaimg.cn/large/008i3skNgy1gw3yd3fyu0j312o0bgwg8.jpg)



> 例题

![image-20211105081030377](https://tva1.sinaimg.cn/large/008i3skNgy1gw3yer7lm2j31da0kmtc3.jpg)



![image-20211105081043812](https://tva1.sinaimg.cn/large/008i3skNgy1gw3yezhfzwj31fb0u0q61.jpg)



哈夫曼编码的算法实现

![image-20211105081358369](https://tva1.sinaimg.cn/large/008i3skNgy1gw3yicun5fj31pm0u0n2k.jpg)

![image-20211105082127818](https://tva1.sinaimg.cn/large/008i3skNgy1gw3yq62p8sj31ig0u0jzb.jpg)



![image-20211105082151718](https://tva1.sinaimg.cn/large/008i3skNgy1gw3yqkgnnmj31a10u0qat.jpg)



#### **（6）文件的编码解码**

![image-20211105092018530](https://tva1.sinaimg.cn/large/008i3skNgy1gw40fdll0xj31hi0u0agp.jpg)

![image-20211105092255932](https://tva1.sinaimg.cn/large/008i3skNgy1gw40i3w8hkj31da0u0k2j.jpg)



> 编码

![image-20211105092836507](https://tva1.sinaimg.cn/large/008i3skNgy1gw40o0irfgj31900mstbi.jpg)



> 解码

![image-20211105092947371](https://tva1.sinaimg.cn/large/008i3skNgy1gw40p86izcj31ei0rq42j.jpg)



> 例子

![image-20211105093140225](https://tva1.sinaimg.cn/large/008i3skNgy1gw40r72op5j31ex0u0agk.jpg)





## 2、图

### （1）概念



> 图
>
> 无向图
>
> 有向图

![image-20211105093409498](https://tva1.sinaimg.cn/large/008i3skNgy1gw40ts0982j31dd0u0jvv.jpg)

> 完全图

![image-20211105093817003](https://tva1.sinaimg.cn/large/008i3skNgy1gw40y2ksopj31l40u0q6v.jpg)

> 稀疏图
>
> 稠密图
>
> 网

![image-20211105094032373](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cwhuqej31r00mgwie.jpg)

> 邻接
>
> 关联（依附）

![image-20211105140553721](https://tva1.sinaimg.cn/large/008i3skNgy1gw48psdi56j31g60l00x7.jpg)

> 定点的度

![image-20211105140920841](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cpib6lj31ix0u0ahk.jpg)

![image-20211105141037239](https://tva1.sinaimg.cn/large/008i3skNgy1gw48tft58cj31860u077m.jpg)

> 路径
>
> 路径长度

![image-20211105141418427](https://tva1.sinaimg.cn/large/008i3skNgy1gw48xab4gwj31az0u0n13.jpg)

> 路径
>
> 路径长度
>
> 回路
>
> 简单路径
>
> 简单回路径（简单环）

![image-20211105141758642](https://tva1.sinaimg.cn/large/008i3skNgy1gw49147l4rj31n90u0qa4.jpg)

> 连通图（强连通图）

![image-20211105142036703](https://tva1.sinaimg.cn/large/008i3skNgy1gw493u628cj31fh0u0grr.jpg)

> 权与网

![image-20211105143955670](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cs8i16j31ty0h60vx.jpg)



> 子图

![image-20211105144323582](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d5dzuwj31mh0u0n27.jpg)





> 连通分量



![image-20211105145040712](https://tva1.sinaimg.cn/large/008i3skNgy1gw49z4xv7pj31ol0u0tf3.jpg)



> 强连通分量

![image-20211105145242046](https://tva1.sinaimg.cn/large/008i3skNgy1gw4a17xbakj31ke0la778.jpg)



> 极小连通子图
>
> 生成树
>
> 生成森林



![image-20211105145638312](https://tva1.sinaimg.cn/large/008i3skNgy1gw4a5bjkwzj31i20u0n2y.jpg)





### （2）图的存储

![image-20211105152434420](https://tva1.sinaimg.cn/large/008i3skNgy1gw4ayekgflj31mj0u0jxx.jpg)



#### 2.1 邻接矩阵（数组）表示法

> 图的邻接矩阵

![image-20211105153342305](https://tva1.sinaimg.cn/large/008i3skNgy1gw97crfnvyj31fh0u0443.jpg)

- 无向图邻接矩阵

![image-20211105153953836](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cxklqqj31mn0u0jy3.jpg)

- 有向图的邻接矩阵

![image-20211105160730545](https://tva1.sinaimg.cn/large/008i3skNgy1gw4ce8drwyj31h80u0grs.jpg)

![image-20211105161004282](https://tva1.sinaimg.cn/large/008i3skNgy1gw4ce5q9kfj31bx0u0q8c.jpg)





> 网（有权图）的邻接矩阵

![image-20211105161447607](https://tva1.sinaimg.cn/large/008i3skNgy1gw4cenpthyj31mj0u0gr3.jpg)



#### 2.2 邻接矩阵的建立



![image-20211105162338752](https://tva1.sinaimg.cn/large/008i3skNgy1gw4cnvmzztj31g30u0wld.jpg)



无向邻接矩阵的创建

![image-20211105162704874](https://tva1.sinaimg.cn/large/008i3skNgy1gw4crgg7s3j31dx0u0797.jpg)



![image-20211105163016186](https://tva1.sinaimg.cn/large/008i3skNgy1gw4cur9r1mj31ir0u0tft.jpg)

找顶点下标

![image-20211105163650832](https://tva1.sinaimg.cn/large/008i3skNgy1gw4d1l9s0yj31nk0rg42e.jpg)



![image-20211105163746757](https://tva1.sinaimg.cn/large/008i3skNgy1gw4d2jxjk7j320k0s8agu.jpg)





**==从无向网-> 无向图与有向网的建立==**

![image-20211105164343566](https://tva1.sinaimg.cn/large/008i3skNgy1gw4d8rjwpmj31ej0u0gsp.jpg)





![image-20211105164507872](https://tva1.sinaimg.cn/large/008i3skNgy1gw4da818huj31gm0u00zh.jpg)





![image-20211105164843166](https://tva1.sinaimg.cn/large/008i3skNgy1gw4ddxx7dvj31si0lgtdl.jpg)



#### 2.3 邻接表法

![image-20211105200847066](https://tva1.sinaimg.cn/large/008i3skNgy1gw4j65vsudj31qo0u0k0e.jpg)

- 使用邻接表实现**无向图**

![image-20211105201745789](https://tva1.sinaimg.cn/large/008i3skNgy1gw4jfg2vbxj31m10u0grs.jpg)

- 使用邻接表实现**有向图**

![image-20211105202416192](https://tva1.sinaimg.cn/large/008i3skNgy1gw4jm7m90sj31rn0u0qan.jpg)



> 使用邻接表实现**有向网**

![image-20211105202854740](https://tva1.sinaimg.cn/large/008i3skNgy1gw4jr1uw4tj31fd0u0q8h.jpg)





> 图的邻接表算法及代码

![image-20211105203412082](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d25yb6j31it0u0jys.jpg)



![image-20211105203519472](https://tva1.sinaimg.cn/large/008i3skNgy1gw4jxr5kvdj31hn0u0ter.jpg)



![image-20211105203647329](https://tva1.sinaimg.cn/large/008i3skNgy1gw4jz8nklvj31ao0ngq73.jpg)



![image-20211105203923225](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d0r9ndj31ig0u011h.jpg)



![image-20211105204247394](https://tva1.sinaimg.cn/large/008i3skNgy1gw4k5hkscej31op0u0100.jpg)





![image-20211105204450684](https://tva1.sinaimg.cn/large/008i3skNgy1gw4k7moxtfj31ly0tan5g.jpg)





![image-20211105210649587](https://tva1.sinaimg.cn/large/008i3skNgy1gw4kuhzop1j31na0u0guc.jpg)



**邻接表特点：**

![image-20211106075659045](https://tva1.sinaimg.cn/large/008i3skNgy1gw53mzltu9j31m10u00zw.jpg)

> 邻接矩阵与邻接表的关系与区别

![image-20211106075909747](https://tva1.sinaimg.cn/large/008i3skNgy1gw53p9be2lj31ue0tewl4.jpg)



![image-20211106080242159](https://tva1.sinaimg.cn/large/008i3skNgy1gw53sy3wy4j31q80u0gs1.jpg)



#### 2.4 十字链表





![image-20211106082548987](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cq6iqvj31ed0u0gpz.jpg)



![image-20211106082908023](https://tva1.sinaimg.cn/large/008i3skNgy1gw54kfug17j31fc0u0n2j.jpg)



#### 2.5 邻接多重表

![image-20211106091329827](https://tva1.sinaimg.cn/large/008i3skNgy1gw55um5sdtj31iq0u0jyv.jpg)



### （3）图的遍历



![image-20211106091814519](https://tva1.sinaimg.cn/large/008i3skNgy1gw55zj3gg2j31qw0u0grl.jpg)



![image-20211106092146124](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cw113rj31ni0u0tf2.jpg)

#### ① 深度优先搜索遍历

> Depth_First Search -- DFS 一条道走到黑



![image-20211106092722175](https://tva1.sinaimg.cn/large/008i3skNgy1gw5691882ij31af0u0dkc.jpg)



![image-20211106093152976](https://tva1.sinaimg.cn/large/008i3skNgy1gw56dq6z2tj31lo0u0n2k.jpg)



**深度优选遍历算法实现**

==**邻接矩阵表示无向图深度遍历实现**==

![image-20211106093820369](https://tva1.sinaimg.cn/large/008i3skNgy1gw56kfwwt2j31jn0u0q8c.jpg)



![image-20211106094216499](https://tva1.sinaimg.cn/large/008i3skNgy1gw56ojihh1j31rm0u0n59.jpg)



DFS算法效率分析

![image-20211106100225610](https://tva1.sinaimg.cn/large/008i3skNgy1gw579huv49j31mj0u0wlv.jpg)



非连通图的深度优选遍历

![image-20211106100558354](https://tva1.sinaimg.cn/large/008i3skNgy1gw57d8ho8dj31qe0rm0wm.jpg)





#### ② 广度优先搜索遍历

> Breadth_First Search -- BFS



![image-20211106100915194](https://tva1.sinaimg.cn/large/008i3skNgy1gw97czqqt7j31qs0tuq89.jpg)





**非连通图的广度优先遍历**

![image-20211106101007401](https://tva1.sinaimg.cn/large/008i3skNgy1gw57hi6wsij31is0ssdjx.jpg)



![image-20211106183539070](https://tva1.sinaimg.cn/large/008i3skNgy1gw5m3jq1ekj31h40u0q8m.jpg)



![image-20211106184103165](https://tva1.sinaimg.cn/large/008i3skNgy1gw5m94ic44j31670u0443.jpg)



BSF算法效率分析

![image-20211106184309039](https://tva1.sinaimg.cn/large/008i3skNgy1gw5mbb5882j31lm0k2tei.jpg)



![image-20211106184511185](https://tva1.sinaimg.cn/large/008i3skNgy1gw5mdfbo1sj31qy0r4n2a.jpg)





### （3）图的应用

#### 1、生成树



![image-20211106184929320](https://tva1.sinaimg.cn/large/008i3skNgy1gw5mhwi319j31990u0wm5.jpg)



![image-20211106185113383](https://tva1.sinaimg.cn/large/008i3skNgy1gw5mjraubfj31m40quq8v.jpg)



![image-20211107111810057](https://tva1.sinaimg.cn/large/008i3skNgy1gw6f2mrj0lj31i60u0n44.jpg)



![image-20211107111933965](https://tva1.sinaimg.cn/large/008i3skNgy1gw6f430ca9j31hu0u0n3w.jpg)



![image-20211107112221445](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d96citj31j30u010o.jpg)





##### ①  构造最小生成树MST



![image-20211107112829885](https://tva1.sinaimg.cn/large/008i3skNgy1gw6fddgozfj31ld0u0q8y.jpg)



![image-20211107113031382](https://tva1.sinaimg.cn/large/008i3skNgy1gw6ffhikqjj31ff0u0q8g.jpg)



##### ② 构造最小生成树之Prim算法

![image-20211107120125346](https://tva1.sinaimg.cn/large/008i3skNgy1gw6gbnno67j31md0u0afq.jpg)



##### ③ 构造最小生成树之kruskal算法

克鲁斯卡尔-kruskal

![image-20211107120704344](https://tva1.sinaimg.cn/large/008i3skNgy1gw6ghih5jfj31el0u0qaf.jpg)



![image-20211107120928584](https://tva1.sinaimg.cn/large/008i3skNgy1gw6gk0aywmj31oc0u0gql.jpg)





#### 2、最短路径问题

![image-20211107121314486](https://tva1.sinaimg.cn/large/008i3skNgy1gw6gnxild8j31k2092767.jpg)



![image-20211107121332077](https://tva1.sinaimg.cn/large/008i3skNgy1gw6go9sezbj315l0u0tgz.jpg)



![image-20211107121420699](https://tva1.sinaimg.cn/large/008i3skNgy1gw6gp31cvzj31nc0u0q9q.jpg)



![image-20211107121600378](https://tva1.sinaimg.cn/large/008i3skNgy1gw6gqsnzwsj31ym0l0wj6.jpg)



![image-20211107121718768](https://tva1.sinaimg.cn/large/008i3skNgy1gw6gs606d7j31pv0u0n20.jpg)





![image-20211107121847102](https://tva1.sinaimg.cn/large/008i3skNgy1gw6gtpam14j31to0u0wle.jpg)



![image-20211107122241686](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d9lmmjj31m60n80wv.jpg)



##### ① Dijkstra（迪杰斯特拉）算法

![image-20211108143157138](https://tva1.sinaimg.cn/large/008i3skNgy1gw7qakvnkxj31no068q3w.jpg)

![image-20211108142643433](https://tva1.sinaimg.cn/large/008i3skNgy1gw7q5725mzj31er0u0gsv.jpg)



![image-20211108142718407](https://tva1.sinaimg.cn/large/008i3skNgy1gw7q5q0nr9j31d00u00zr.jpg)



![image-20211108143133065](https://tva1.sinaimg.cn/large/008i3skNgy1gw7qahz7etj31f00u046q.jpg)



##### ② Floyd（弗洛伊德）算法

![image-20211108143813379](https://tva1.sinaimg.cn/large/008i3skNgy1gw7qh2q4dej31120iqq4t.jpg)





![image-20211108143907999](https://tva1.sinaimg.cn/large/008i3skNgy1gw7qi35r4aj31gb0u0wkl.jpg)



![image-20211108144101899](https://tva1.sinaimg.cn/large/008i3skNgy1gw97crvxdhj31gl0u0ahy.jpg)



#### 3、图的拓扑

> 有向无环图

![image-20211108144514253](https://tva1.sinaimg.cn/large/008i3skNgy1gw7qojgl10j31ej0u0wk3.jpg)





![image-20211108150930879](https://tva1.sinaimg.cn/large/008i3skNgy1gw7re22aiij31fj0u0ahf.jpg)





![image-20211108151006408](https://tva1.sinaimg.cn/large/008i3skNgy1gw7reae5vyj31ym0u0qab.jpg)







![image-20211108151322356](https://tva1.sinaimg.cn/large/008i3skNgy1gw7rhnl92hj313c0u00vw.jpg)

![image-20211108151342803](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cyc18oj31540u0wiu.jpg)

![image-20211108151421187](https://tva1.sinaimg.cn/large/008i3skNgy1gw7rio80inj31150u0ae7.jpg)



![image-20211108151513476](https://tva1.sinaimg.cn/large/008i3skNgy1gw97csth07j31ek0u0aej.jpg)



![image-20211108151525880](https://tva1.sinaimg.cn/large/008i3skNgy1gw7rjsncxej31ib0u0q9h.jpg)





#### 4、关键路径

![image-20211108152239982](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d8ofkwj31fv0u00zo.jpg)

![image-20211108152539481](https://tva1.sinaimg.cn/large/008i3skNgy1gw7rugg5noj31em0u0tff.jpg)



![image-20211108153001500](https://tva1.sinaimg.cn/large/008i3skNgy1gw7ryzg8qqj31lv0u0444.jpg)





![image-20211108153107596](https://tva1.sinaimg.cn/large/008i3skNgy1gw7s04zlv4j31u30u0jxy.jpg)



![image-20211108153901945](https://tva1.sinaimg.cn/large/008i3skNgy1gw7s9bsisoj31l40u0jyi.jpg)









# 五、排序和查找

## （1）查找

**前言**

> **线性表**
>
> 1、顺序查找
>
> 2、折半查找
>
> 3、分块查找（索引查找）
>
> **树**
>
> 4、二叉排序树
>
> 5、红黑树
>
> 6、B-树
>
> 7、B+树
>
> 8、键树
>
> **散列表**





### 1、顺序查找

![image-20211111194428351](https://tva1.sinaimg.cn/large/008i3skNgy1gwbg6nrfibj31iy0u0wkz.jpg)



> 形式一：



![image-20211109200622881](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d2l1d1j31jd0u0n49.jpg)



> 形式2

![image-20211109200731082](https://tva1.sinaimg.cn/large/008i3skNgy1gw95m0iionj31gu0roadt.jpg)



> 形式3

![image-20211109200818934](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d790qdj31ss0u0444.jpg)



> 最牛改进方法-增加一个哨兵

不用判断是否越界

![image-20211109200936162](https://tva1.sinaimg.cn/large/008i3skNgy1gw95o6pg1sj31680gmmzp.jpg)



![image-20211109201017146](https://tva1.sinaimg.cn/large/008i3skNgy1gw97da31t8j31mn0u0n3r.jpg)



> 顺序查找代码

```c
#include<stdio.h>
#include<mm_malloc.h>
#define INIT_SIZE 6  // 假定顺序表长度最大为4，为了方便测试，后期可进行更改
typedef int dataType;

typedef struct 
{
    dataType *data;
    int size;// 当前数组有效元素的个数
    int maxSize;// 最大容量
} SqList;


// 初始化顺序表
void initList(SqList *l){

    l->data = (dataType *)malloc(sizeof(dataType) * INIT_SIZE); // 给顺序表分配空间
    if (NULL==l->data)
    {
        printf("动态内存分配失败");
        exit(-1); //终止程序
    }else{
        l->maxSize=INIT_SIZE; // 顺序表长度为100 
        l->size=0;// 当前表的长度为0
    }
}

//判断当前顺序表是否为空
bool isEmpty(SqList *l){
    if (l->size==0)
    {
        return true;
    }else
    {
        return false;
    }
    
}
// 判断顺序表是否已满
bool isFull(SqList *l){
    if (l->size==l->maxSize)
    {
        return true;
    }else
    {
        return false;
    }
}

// 在顺序表l中追加元素val
bool appendList(SqList *l,dataType val){
    if (isFull(l))
    {
        return false;//追加失败
    }
    // 不满的时候可以进行追加
    l->data[l->size] = val;
    l->size++;
    return true;//追加成功
}

// 在第顺序表l中的第pos个位置插入元素val
bool insertList(SqList *l,int pos,dataType val){
    /*
    分析：
        1、如果顺序表已满，则退出程序
        2、如果顺序表插入越界，则退出程序
            超过
        3、非上述两种情况，则正常插入
    */
   if (isFull(l))
   {
       printf("\n顺序表已满!\n");
       return false;
   }
   if (pos<1 || pos>l->size+1)
   {
       printf("\n顺序表越界！\n");
       return false;
   }

   for (int i = l->size-1; i >=pos-1; i--)
   {
       l->data[i+1] = l->data[i];
   }
   l->data[pos-1] = val; // 赋值
   l->size++;
    return true;
   
}

bool deleteList(SqList *l,int pos,dataType *resultVal){

    if (isEmpty(l))
    {
       printf("顺序表为空\n");
       return false;
    }
    
    if (pos<1 || pos>l->size)
    {
        printf("删除越界\n");
        return false;
    }
    *resultVal = l->data[pos-1]; // 接收被删除元素的值
    for (int i = pos; i <= l->size-1; i++)
    {
        l->data[i-1] = l->data[i];// 全部前移
    }
    l->size--;
    return true;

}

// 显示顺序表
void showList(SqList *l)
{
    if (isEmpty(l))
    {
        printf("数组为空");
    }
    else
    {
        
        printf("当前顺序表：\n");
        for (int i = 0; i < l->size; i++)
        {
            
            printf("%d ", l->data[i]);
        }
    }
}
// 求顺序表中第pos的元素的值
dataType getData(SqList *l,int pos){
    //先判断是否越界，越界则退出程序
    if (pos<1 || pos>l->size)
    {
       printf("查找越界\n");
       exit(-1);
    }
    return l->data[pos-1];
}
// 求顺序表中查找值为val的元素，返回该元素位置
int searchData(SqList *l,int val){
    //1、遍历；2、比较
    for (int i = 0; i < l->size; i++)
    {
        if (l->data[i] == val)
        {
            return i+1;
        }
    }
    return 0;// 0表示未找到
}

/*
1、顺序查找v1
*/
int SeqSearch(SqList *s, dataType val){
    for (int i = 1; i < s->size; i++)
    {
        if(val == s->data[i]){
            return i;
        }
    }
    retun 0;
}


/*
1、顺序查找v2
*/
int SeqSearch2(SqList *s, dataType val){
    int i;
    for (i=s->size; s->data[i]!=val ; --i)
    {
        if(i<=0){
            break;
        } 
    }
    if (i>0)
    {
        return i;
    }
    return 0;
}

/*
1、顺序查找v3 -添置哨兵
*/

int SeqSearch3(SqList *s, dataType val){
    s->data[0] = val;
    int i;
    for (i=s->size; s->data[i]!=val ; i--)
    {
    }
    return i;
}

int main(){
    SqList list;
    initList(&list);
    
    //构造一组数 a[0]=NULL,a[1] = 5, a[2] = 7, a[3]=19 a[4] =a[21] a[13]

    appendList(&list,-99999); // 0号位置
    appendList(&list,5); //    1号位置
    appendList(&list,7); //    ....
    appendList(&list,19);
    appendList(&list,21);
    appendList(&list,13);
    showList(&list);
    /** 构造完成后为
    -99999 5 7 19 21 13
       0   1 2 3  4  5
    */
    int pos = SeqSearch3(&list,19);
    printf("\n该元素的下标为：%d",pos);
    

   return 0;
}

```







### 2、折半查找

演算过程

![image-20211109195348931](https://tva1.sinaimg.cn/large/008i3skNgy1gw957ss39fj31t40la780.jpg)



思想

![image-20211109195920647](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d1ofi4j31kh0u0tfw.jpg)



  ![image-20211109200216049](https://tva1.sinaimg.cn/large/008i3skNgy1gw95gk0bb1j31gk0u0jz7.jpg)





> 补充-递归算法实现

![image-20211109200458804](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cz39bij31fz0u0gr6.jpg)

> 折半查找代码实现

```c
/*
1、折半查找
*/
int binSearch(SqList *s, dataType val){
    int low = 1;
    int high = s->size;
    while (low<high)
    {
        int mid = (low+high)/2;
        if (val == s->data[mid]) // 1、当val刚好为中间值时候，直接返回
        {
            return mid;
        }else if(val < s->data[mid]) // 2、当val小于中间位置的值，则说明要继续往左边找，否则需要往右边找
        {
            high = mid -1;
        }else
        {
            low = mid+1;
        }  
    }
    return 0;
    
}
int main(){
    SqList list;
    initList(&list);
    
    //构造一组数 a[0]=NULL,a[1] = 5, a[2] = 7, a[3]=19 a[4] =a[21] a[13]

    appendList(&list,-99999); // 0号位置
    appendList(&list,5); //    1号位置
    appendList(&list,7); //    ....
    appendList(&list,19);
    appendList(&list,21);
    appendList(&list,13);
    showList(&list);
    /** 构造完成后为
    -99999 5 7 19 21 13
       0   1 2 3  4  5
    */
    int pos = binSearch(&list,19);
    printf("\n该元素的下标为：%d",pos);
   return 0;
}

```

>  折半查找性能分析

![image-20211109202636835](https://tva1.sinaimg.cn/large/008i3skNgy1gw965vz9jnj31ro0u0jx3.jpg)

![image-20211109203616460](https://tva1.sinaimg.cn/large/008i3skNgy1gw96fxj75rj31jp0u0q9g.jpg)

### 3、索引查找（分块查找）



![image-20211109204139596](https://tva1.sinaimg.cn/large/008i3skNgy1gw96ljcj0aj31lj0u0tgk.jpg)



![image-20211109204513940](https://tva1.sinaimg.cn/large/008i3skNgy1gw96p985mej31c20u0jwn.jpg)



![image-20211109204533476](https://tva1.sinaimg.cn/large/008i3skNgy1gw96pl7ax3j31qm0mu44y.jpg)





> 查找方法比较



![image-20211109204654107](https://tva1.sinaimg.cn/large/008i3skNgy1gw96r01snej31d20pq78c.jpg)



### 4、二叉排序树

![image-20211109205850626](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d6cgsjj31f90u044j.jpg)



![image-20211109210402920](https://tva1.sinaimg.cn/large/008i3skNgy1gw978tvh2ej31s60s87bm.jpg)



![image-20211109210419592](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d86vg8j31fu0l6go3.jpg)

![image-20211109210528120](https://tva1.sinaimg.cn/large/008i3skNgy1gw97abadf6j31500kgq64.jpg)



![image-20211109210612589](https://tva1.sinaimg.cn/large/008i3skNgy1gw97b2pr70j30tk0kg40h.jpg)



![image-20211110080743595](https://tva1.sinaimg.cn/large/008i3skNgy1gw9qfejpelj31iq0u0wkc.jpg)



> 二叉排序树的操作-查找

![image-20211110081258980](https://tva1.sinaimg.cn/large/008i3skNgy1gw9qkv9at3j31bx0u0dlq.jpg)

![image-20211110081815512](https://tva1.sinaimg.cn/large/008i3skNgy1gw9qqct3ltj31pv0u0dna.jpg)





![image-20211110082155495](https://tva1.sinaimg.cn/large/008i3skNgy1gw9qu7906mj31lr0u0dn4.jpg)



![image-20211110083125521](https://tva1.sinaimg.cn/large/008i3skNgy1gw9r42kl4xj31q20suad8.jpg)



> 二叉排序树的生成

![image-20211110084311735](https://tva1.sinaimg.cn/large/008i3skNgy1gw9rgb1uh1j31gu0u0gqf.jpg)





> 二叉排序树的删除

![image-20211110084339461](https://tva1.sinaimg.cn/large/008i3skNgy1gw9rgs379yj31oc0u0wmm.jpg)



![image-20211110084422336](https://tva1.sinaimg.cn/large/008i3skNgy1gw9rhit5sgj315s0u0djm.jpg)





![image-20211110085110093](https://tva1.sinaimg.cn/large/008i3skNgy1gw9romreqtj31jg0u0n3j.jpg)





![image-20211110085321524](https://tva1.sinaimg.cn/large/008i3skNgy1gw9rqx45gyj31hy0u0tdb.jpg)



**二叉排序树的删除算法**

==待补充....==







![image-20211110091654199](https://tva1.sinaimg.cn/large/008i3skNgy1gw9sff8tfbj31g70u0jyc.jpg)





### 5、平衡二叉树

> 引子

![image-20211110091822442](https://tva1.sinaimg.cn/large/008i3skNgy1gw9sgwliuaj31nm0nwadu.jpg)



> 平航二叉树的定义

![image-20211110092127935](https://tva1.sinaimg.cn/large/008i3skNgy1gw9sk4xfb8j31wm0t00ys.jpg)



![image-20211110092216520](https://tva1.sinaimg.cn/large/008i3skNgy1gw9skyf4aoj31x40nkaf2.jpg)



![image-20211110092623158](https://tva1.sinaimg.cn/large/008i3skNgy1gw9sp8vijgj31ih0u0dkd.jpg)



> 失衡二叉排序树的分析与调整

![image-20211110092926107](https://tva1.sinaimg.cn/large/008i3skNgy1gw9ssg03c3j31fz0u07a3.jpg)





> 失衡



![image-20211110162049392](https://tva1.sinaimg.cn/large/008i3skNgy1gwa4og5uvaj31os0u044g.jpg)



![image-20211110162315160](https://tva1.sinaimg.cn/large/008i3skNgy1gwa4r0a7dtj31cp0u0q8a.jpg)

​	![image-20211111141614394](https://tva1.sinaimg.cn/large/008i3skNgy1gwb6p4x1exj317g05mt9v.jpg)





### 6、B-树



### 7、B+树





### 8、散列表（Hash表）



![image-20211111153757928](https://tva1.sinaimg.cn/large/008i3skNgy1gwb92bitaxj31h50u0dm1.jpg)



![image-20211111153906737](https://tva1.sinaimg.cn/large/008i3skNgy1gwb93d9zb6j31sw0q4dmn.jpg)



![image-20211111153926625](https://tva1.sinaimg.cn/large/008i3skNgy1gwb93p8f6gj31sa0me0y1.jpg)



![image-20211111153635914](https://tva1.sinaimg.cn/large/008i3skNgy1gwbctto3ttj31sk0u0445.jpg)

> 同义词：具有同函数值的多个关键字





![image-20211111154100061](https://tva1.sinaimg.cn/large/008i3skNgy1gwb95c0z9pj31dt0u0dlq.jpg)



#### 散列函数的构造方法 

![image-20211111154224107](https://tva1.sinaimg.cn/large/008i3skNgy1gwb96s1vp3j31g00u0n3k.jpg)



> 直接定址法

![image-20211111154623605](https://tva1.sinaimg.cn/large/008i3skNgy1gwb9axy4qij31ho0u0n3o.jpg)





> 除留余数法



![image-20211111154743456](https://tva1.sinaimg.cn/large/008i3skNgy1gwb9cbvdhgj31au0u0aeo.jpg)





#### 散列表中解决冲突的办法

> 开放地址法



![image-20211111162412956](https://tva1.sinaimg.cn/large/008i3skNgy1gwbaebfowwj31jj0u0gs3.jpg)



![image-20211111163039005](https://tva1.sinaimg.cn/large/008i3skNgy1gwbal2mc22j31iz0u0dng.jpg)



![image-20211111163234221](https://tva1.sinaimg.cn/large/008i3skNgy1gwban01iq0j31bx0u0dnu.jpg)



![image-20211111163825156](https://tva1.sinaimg.cn/large/008i3skNgy1gwbat377m8j31jl0u00z8.jpg)





![image-20211111163906219](https://tva1.sinaimg.cn/large/008i3skNgy1gwbats5gxdj317w0qagp0.jpg)





> 链地址法 | 拉链法





![image-20211111165546545](https://tva1.sinaimg.cn/large/008i3skNgy1gwbbb4twqrj31ix0u0q8x.jpg)





#### 散列表上的查找

![image-20211111165828898](https://tva1.sinaimg.cn/large/008i3skNgy1gwbbdzcd1ej315i0u0adf.jpg)



例题：

![image-20211111170109133](https://tva1.sinaimg.cn/large/008i3skNgy1gwbbgqbgj8j31j20u045w.jpg)



![image-20211111170335184](https://tva1.sinaimg.cn/large/008i3skNgy1gwbbj9j9kfj31j30u0ai3.jpg)

![image-20211111170437655](https://tva1.sinaimg.cn/large/008i3skNgy1gwbbkc8753j31hu0u0wiv.jpg)



![image-20211111174219293](https://tva1.sinaimg.cn/large/008i3skNgy1gwbcnkwr3zj31ec0u0wi4.jpg)





![image-20211111174318493](https://tva1.sinaimg.cn/large/008i3skNgy1gwbcolc2crj31ds0u0wkb.jpg)



![image-20211111174406687](https://tva1.sinaimg.cn/large/008i3skNgy1gwbctu73skj31eu0rggof.jpg)



![image-20211111174505907](https://tva1.sinaimg.cn/large/008i3skNgy1gwbcs8surpj31ao0u078a.jpg)



## （2）排序



> 插入排序
>
> ①、直接插入排序
>
> ②、折半插入排序
>
> ③、希尔排序



![image-20211106193204901](https://tva1.sinaimg.cn/large/008i3skNgy1gw5nq8geoej314b0u0wjv.jpg)

![image-20211106193232613](https://tva1.sinaimg.cn/large/008i3skNgy1gw5nqpkwmgj31ro0kwgqi.jpg)



![image-20211106193334315](https://tva1.sinaimg.cn/large/008i3skNgy1gw97db0i50j31pw0kcn0t.jpg)



![image-20211106193454598](https://tva1.sinaimg.cn/large/008i3skNgy1gw5nt5xmjdj31bc0g042d.jpg)



![image-20211106193655828](https://tva1.sinaimg.cn/large/008i3skNgy1gw97cwz4yxj31lc0fwdj6.jpg)



![image-20211106193708999](https://tva1.sinaimg.cn/large/008i3skNgy1gw5nvhlsppj31900sq42z.jpg)





![image-20211106193832206](https://tva1.sinaimg.cn/large/008i3skNgy1gw5nwxxhs1j31hg0fg0vm.jpg)







![image-20211106193853444](https://tva1.sinaimg.cn/large/008i3skNgy1gw5nxbfns9j314c0l0q5s.jpg)





![image-20211106193932537](https://tva1.sinaimg.cn/large/008i3skNgy1gw5nxzpqpfj31fi0u0q8i.jpg)



![image-20211106194033206](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d7pmw2j31mq0oktf5.jpg)

![image-20211106194138229](https://tva1.sinaimg.cn/large/008i3skNgy1gw97d5xbguj31hc0eg77h.jpg)



> 插入法排序



![image-20211111180159387](https://tva1.sinaimg.cn/large/008i3skNgy1gwbd81pe83j31m60u0jwe.jpg)



![image-20211111180235585](https://tva1.sinaimg.cn/large/008i3skNgy1gwbd8n58r5j31rm0ts0xv.jpg)



![image-20211106194756191](https://tva1.sinaimg.cn/large/008i3skNgy1gw5o6qbkw6j31c20u0jw3.jpg)



![image-20211106194853533](https://tva1.sinaimg.cn/large/008i3skNgy1gw97dam3x7j31eg0oen0f.jpg)



### ① 直接插入排序

![image-20211111180508903](https://tva1.sinaimg.cn/large/008i3skNgy1gwbdbbbl0jj31o00g00v8.jpg)



![image-20211111181117497](https://tva1.sinaimg.cn/large/008i3skNgy1gwbdhp9eiej31gn0u0gqi.jpg)

**第一个直接放入即可，后面的[2-n]个按照上述规则插入**



> 改进直接插入法-带哨兵

![image-20211111181552948](https://tva1.sinaimg.cn/large/008i3skNgy1gwbdmi86kuj31ha0u0jxq.jpg)



![image-20211111181932540](https://tva1.sinaimg.cn/large/008i3skNgy1gwbdqaa4d5j31cd0u00xc.jpg)





![image-20211111183111915](https://tva1.sinaimg.cn/large/008i3skNgy1gwbe2f2kzkj316z0u0q7d.jpg)





![image-20211111183308488](https://tva1.sinaimg.cn/large/008i3skNgy1gwbe4fwuigj318y0p6423.jpg)



![image-20211111183321400](https://tva1.sinaimg.cn/large/008i3skNgy1gwbe4nzgzuj31dq0nkq5i.jpg)



​	![image-20211111183446206](https://tva1.sinaimg.cn/large/008i3skNgy1gwbe64khkfj31gy0te0xx.jpg)





### ② 折半插入排序

![image-20211111184440743](https://tva1.sinaimg.cn/large/008i3skNgy1gwbegft9qlj31bq0u0agd.jpg)





### ③ 希尔排序-插入排序

![image-20211111185525807](https://tva1.sinaimg.cn/large/008i3skNgy1gwbermgqwfj31jj0u0dk7.jpg)





![image-20211111185802442](https://tva1.sinaimg.cn/large/008i3skNgy1gwbeuc85qfj31ie0t278u.jpg)



![image-20211111185856159](https://tva1.sinaimg.cn/large/008i3skNgy1gwbev9w58wj31az0u0dmy.jpg)



![image-20211111190145563](https://tva1.sinaimg.cn/large/008i3skNgy1gwbey7wk4hj31h40lw0wv.jpg)



![image-20211111190201764](https://tva1.sinaimg.cn/large/008i3skNgy1gwbeyhiot1j31h40ocdkg.jpg)



![image-20211111190331196](https://tva1.sinaimg.cn/large/008i3skNgy1gwbf01u58vj31p60swgrk.jpg)



![image-20211111190525706](https://tva1.sinaimg.cn/large/008i3skNgy1gwbf21015ij31dh0u0tdm.jpg)

![image-20211111191623377](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211113183743.png)





![image-20211111191804235](https://tva1.sinaimg.cn/large/008i3skNgy1gwbff6yuppj31bl0u0dkl.jpg)



![image-20211111192015259](https://tva1.sinaimg.cn/large/008i3skNgy1gwbfhgmlr8j31n40i8wis.jpg)











> 交换排序
>
> ④、冒牌排序
>
> ⑤、快速排序



### ④ 冒泡排序

![image-20211111203128799](https://tva1.sinaimg.cn/large/008i3skNgy1gwbhjkqfljj31n70u0dln.jpg)



![image-20211111203650789](https://tva1.sinaimg.cn/large/008i3skNgy1gwbhp5ilytj312j0u0aee.jpg)

> C语言实现

![image-20211111203842042](https://tva1.sinaimg.cn/large/008i3skNgy1gwbhr2ue6zj318t0u0437.jpg)

![image-20211111203940339](https://tva1.sinaimg.cn/large/008i3skNgy1gwbhs3jt74j31ms0au76e.jpg)



![image-20211111204059115](https://tva1.sinaimg.cn/large/008i3skNgy1gwbhtgqrccj31g90u0agc.jpg)



![image-20211111204214538](https://tva1.sinaimg.cn/large/008i3skNgy1gwbhurtzujj31cj0u079k.jpg)





> Java实现

```java
#include<stdio.h>
void main(){

	int arr[] = {3,9,-1,10,-2};

	int j;
	int i;
	int t; //临时变量
	int arrLen = sizeof(arr)/sizeof(int); //数组的长度
	for(i=0;i<arrLen-1;i++){
		for(j=0;j<arrLen-1-i;j++){ //4是递减
			if(arr[j]>arr[j+1]){ //如果前面的数大于后面的就交换
				t = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = t;
			}
		}
	}

	//结果
	for(j=0;j<5;j++){
		printf("%d ",arr[j]);
	}
	getchar();
}  
```



![image-20211111205017823](https://tva1.sinaimg.cn/large/008i3skNgy1gwbi35bx5lj31910u077x.jpg)



![image-20211111205033146](https://tva1.sinaimg.cn/large/008i3skNgy1gwbi3ekggtj31j80t0tdo.jpg)





### ⑤ 快速排序（递归思想）

> 快速排序-改进的交换排序-==**递归思想**==

1、找pivot 中心元素

2、找所有比pivot小的元素一律前放，找比它大的元素一律后放

3、此时，形成两个子表

4、最两个字表进行上述操作，继续划分

```
1、找pivot 中心元素

2、找所有比pivot小的元素一律前放，找比它大的元素一律后放

3、此时，形成两个子表
```

4、直到每个字表中只剩下一个元素

![image-20211111205612278](https://tva1.sinaimg.cn/large/008i3skNgy1gwbi9aue8oj31c10u0n2g.jpg)



> 不可取方式-太浪费空间了



![image-20211111210110731](https://tva1.sinaimg.cn/large/008i3skNgy1gwbiehgbwij31i90u0ajh.jpg)



> 快速排序代码实现

![image-20211111215805961](https://tva1.sinaimg.cn/large/008i3skNgy1gwbk1pnodzj31fx0u0tfl.jpg)



> 快速排序时间复杂度

![image-20211111223232120](https://tva1.sinaimg.cn/large/008i3skNgy1gwbl1jalr0j31pu0oun1i.jpg)



> 快速排序空间复杂度

![image-20211111223209483](https://tva1.sinaimg.cn/large/008i3skNgy1gwbl15lle3j31oa0s6tds.jpg)



> 快速排序算法分析：

1、不稳定性

![image-20211111223136826](https://tva1.sinaimg.cn/large/008i3skNgy1gwbl0kmhqzj317a0gaq5e.jpg)

2、不是自然排序（数据越乱反而越好）![image-20211111223256211](https://tva1.sinaimg.cn/large/008i3skNgy1gwbl1yu60wj31k20i2q6b.jpg)

排序不均衡 ，等同于冒泡排序了

![image-20211111223325252](https://tva1.sinaimg.cn/large/008i3skNgy1gwbl2gq4e1j31h60u00zh.jpg)

![image-20211111223339654](https://tva1.sinaimg.cn/large/008i3skNgy1gwbl2pkbkqj31p90u0wlr.jpg)





> 选择排序
>
> ⑥、简单选择排序
>
> ⑦、树形选择排序
>
> ⑧、堆排序



### ⑥ 简单选择排序

![image-20211112080911125](https://tva1.sinaimg.cn/large/008i3skNgy1gwc1plqsagj31rc0u0jz4.jpg)



![image-20211112080922150](https://tva1.sinaimg.cn/large/008i3skNgy1gwc1ppyvytj31ic0u0wir.jpg)



![image-20211112081345008](https://tva1.sinaimg.cn/large/008i3skNgy1gwc1uach8oj31i80u0n26.jpg)





### ⑦ 树形选择排序

### ⑧ 堆排序

> 堆定义

![image-20211112082553933](https://tva1.sinaimg.cn/large/008i3skNgy1gwc26x7ea9j31mp0u043z.jpg)





![image-20211112082518392](https://tva1.sinaimg.cn/large/008i3skNgy1gwc26b4c9gj31c20u0ae9.jpg)



![image-20211112082506569](https://tva1.sinaimg.cn/large/008i3skNgy1gwc263z9anj31e80u079b.jpg)



> 什么是堆排序

![image-20211112082823969](https://tva1.sinaimg.cn/large/008i3skNgy1gwc29ihef6j31xc0iun1r.jpg)



> 堆排序2个问题
>
> 1、建立堆
>
> 2、输出堆顶元素后，调整剩下的元素从新成为一个堆



![image-20211112082737962](https://tva1.sinaimg.cn/large/008i3skNgy1gwc28q6xobj31mo0h0n0g.jpg)



> 堆的调整

![image-20211112083007130](https://tva1.sinaimg.cn/large/008i3skNgy1gwc2bbbgjjj31fm05mq46.jpg)



![image-20211112083344041](https://tva1.sinaimg.cn/large/008i3skNgy1gwc2f2w208j31zm0u045f.jpg)



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwc2hzuz47j30pi0v8dgz.jpg" alt="image-20211112083633158" style="zoom:33%;" /> 



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwc2iheedrj30lm0ti0ts.jpg" alt="image-20211112083701356" style="zoom:33%;" /> 



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwc2jdzk5nj30jy0sw3zm.jpg" alt="image-20211112083752931" style="zoom:33%;" />  

<img src="https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211113183744.png" alt="image-20211112083839750" style="zoom:33%;" /> 

**此时再重复上述操作，将27输出，97调到堆顶元素，97不断比较**

![image-20211112084033671](https://tva1.sinaimg.cn/large/008i3skNgy1gwc2m65m8pj311a09i0tz.jpg) 

![image-20211112092027302](https://tva1.sinaimg.cn/large/008i3skNgy1gwc3rp7l1fj31c80u07bm.jpg)





> 堆的建立



![image-20211112092346829](https://tva1.sinaimg.cn/large/008i3skNgy1gwc3v7rvevj31ps0n8ae1.jpg)



![image-20211112092512235](https://tva1.sinaimg.cn/large/008i3skNgy1gwc3wn2schj31la0u078p.jpg)





![image-20211112092720611](https://tva1.sinaimg.cn/large/008i3skNgy1gwc3yux002j31oj0u0td8.jpg)



![image-20211112092809528](https://tva1.sinaimg.cn/large/008i3skNgy1gwc3zorbayj31ly0u0431.jpg)



![image-20211112092833240](https://tva1.sinaimg.cn/large/008i3skNgy1gwc403qa3bj31fc0u0797.jpg)



![image-20211112092949682](https://tva1.sinaimg.cn/large/008i3skNgy1gwc41fpcnrj31bq0u0jwn.jpg)



![image-20211112093508835](https://tva1.sinaimg.cn/large/008i3skNgy1gwc46yptl8j31ck0u00xt.jpg)



![image-20211112093623939](https://tva1.sinaimg.cn/large/008i3skNgy1gwc489uo80j31k40mkjv0.jpg)



![image-20211112094426320](https://tva1.sinaimg.cn/large/008i3skNgy1gwc4gmmhjaj31g70u0tei.jpg)







> 归并排序

### ⑨归并排序

![image-20211112110223301](https://tva1.sinaimg.cn/large/008i3skNgy1gwc6ptutx0j31w60leq7l.jpg)



![image-20211112110210523](https://tva1.sinaimg.cn/large/008i3skNgy1gwc6pnlov2j31dv0u0q7g.jpg)



![image-20211112110246297](https://tva1.sinaimg.cn/large/008i3skNgy1gwc6r35ziej31qy0u0jul.jpg)



![image-20211112110305891](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211113183745.png)



![image-20211112110540651](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211113183746.png)





> 归并排序的算法

待补充...





> 归并排序的效率分析



![image-20211112110838631](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211113183747.png)



![image-20211112110935379](https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211113183804.png)















> ⑩基数排序

### ⑩ 基数排序（桶排序/箱排序）

![image-20211112111704617](https://tva1.sinaimg.cn/large/008i3skNgy1gwc753691yj31zk0oejwv.jpg)



![image-20211112111849263](https://tva1.sinaimg.cn/large/008i3skNgy1gwc76w05paj31ii0u0agn.jpg)



![image-20211112111958628](https://tva1.sinaimg.cn/large/008i3skNgy1gwc7841rssj31h10u0tfb.jpg)





![image-20211112112044767](https://tva1.sinaimg.cn/large/008i3skNgy1gwc78uvjidj31f90u0jy6.jpg)



> 例2

一副扑克牌52张，❤A->K 13张，♣A->K 13张，♢A->K 13张，♠A->K 13张 总共52张，需先按照花色大小进行排序

**排序步骤：**

==第一趟分配：==

​					==准备4个盒子，按照4种（❤->♣->♢->♠）花色顺序装入==

==第一趟收集==

​					==收集后发现已经按花色排序了==

==第二趟分配==

​					==准备14个盒子，安装A->K大小进行放入==

==第二趟收集==

​					==收集完成后发现，扑克牌排序完成（花色、大小）==

![image-20211112121026914](https://tva1.sinaimg.cn/large/008i3skNgy1gwc8oke1kej31ia0r442a.jpg)



![image-20211112132335581](https://tva1.sinaimg.cn/large/008i3skNgy1gwcasnzvmbj31oq0rg78g.jpg)





> 链式的基数排序

待补充...



![image-20211112132405069](https://tva1.sinaimg.cn/large/008i3skNgy1gwcat6ehtij31f20u0n4j.jpg)









### 各种排序方法的综合比较

> 时间性能

![image-20211112132743925](https://tva1.sinaimg.cn/large/008i3skNgy1gwcawz6y14j31pg0u0n4n.jpg)

==基数排序的缺点：不是所有的情况都适用==

![image-20211112132946623](https://tva1.sinaimg.cn/large/008i3skNgy1gwcaz3z0y6j31rc0l0n40.jpg)

> 空间性能



![image-20211112133204042](https://tva1.sinaimg.cn/large/008i3skNgy1gwcb1ht5tij31jv0u0wlf.jpg)



> 排序的稳定性

**==什么是排序的稳定性？==**

两个关键字的值相等，他们在排序后位置是否变化，如若无变化，则稳定，如若变化，则不稳定。

![image-20211112133441981](https://tva1.sinaimg.cn/large/008i3skNgy1gwcb486mrwj31s60o67as.jpg)



![image-20211112133708773](https://tva1.sinaimg.cn/large/008i3skNgy1gwcb6rlu7ij31u40no45i.jpg)





# 作者&联系



> 公众号/B站：是叶十三

  

<img src="https://yerenping.oss-cn-beijing.aliyuncs.com/img/20211113184305.jpg" alt="扫码_搜索联合传播样式-标准色版" style="zoom:20%;" /> 















